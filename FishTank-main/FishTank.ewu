$version 12.05

// Strings and icons used in the menus
note group Note4
{
  attr Bounds = <-10,420,730,710>;
}

// Menu and Alert components
note group Note3
{
  attr Bounds = <510,10,990,430>;
}

// Interface to the Device
note group Note2
{
  attr Bounds = <260,10,500,140>;
}

// Application and its Menus
note group Note1
{
  attr Bounds = <10,10,250,280>;
}

$rect <1079,480,1259,520>
$output false
resource Resources::Bitmap LightPicture
{
  attr bitmapfile FileName = .\Resources\lightpicture.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1079,599,1278,639>
$output false
resource Resources::Bitmap TemperaturePicture
{
  attr bitmapfile FileName = .\Resources\pngwing.com (1).png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1079,439,1259,479>
$output false
resource Resources::Bitmap MainMenuPicture
{
  attr bitmapfile FileName = .\Resources\main.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1079,519,1259,559>
$output false
resource Resources::Bitmap ContrastPicture
{
  attr bitmapfile FileName = .\Resources\contrastpicture.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1079,560,1259,600>
$output false
resource Resources::Bitmap BrightnessPicture
{
  attr bitmapfile FileName = .\Resources\brightnesspicture.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <0,460,180,500>
$output false
const string MM_Caption =
(
  Default = "Main Menu";
  German = "Hauptmenü";
);

$rect <0,500,180,540>
$output false
const string MM_LightSettings =
(
  Default = "Lights";
  German = "Bildeinstellungen";
);

$rect <0,540,180,580>
$output false
const string MM_TemperatureSettings =
(
  Default = "Temperature";
  German = "Toneinstellungen";
);

$rect <0,580,180,620>
$output false
const string MM_Close =
(
  Default = "Close this Menu";
  German = "Menü verlassen";
);

$rect <180,460,360,500>
$output false
const string LM_Caption =
(
  Default = "Lights";
  German = "Bildeinstellungen";
);

$rect <180,540,360,580>
$output false
const string LM_Brightness =
(
  Default = "Brightness";
  German = "Helligkeit";
);

$rect <180,580,360,620>
$output false
const string LM_Background =
(
  Default = "Background";
  German = "Farbe";
);

$rect <180,620,360,660>
$output false
const string LM_Back =
(
  Default = "Back to Main Menu";
  German = "Zurück zum Hauptmenü";
);

$rect <360,460,540,500>
$output false
const string TM_Caption =
(
  Default = "Temperature";
  German = "Toneinstellungen";
);

$rect <360,500,540,540>
$output false
const string TM_Back =
(
  Default = "Back to Main Menu";
  German = "Zurück zum Hauptmenü";
);

$rect <180,500,360,540>
$output false
const string LM_Contrast =
(
  Default = "Contrast";
  German = "Kontrast";
);

$rect <1070,320,1270,360>
$output false
resource Resources::Bitmap MenuPageBackground
{
  attr bitmapfile FileName = .\Resources\PanelGray.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This component implements a menu item separator.
$rect <720,210,920,250>
$output false
class MenuSeparatorItem : Templates::MenuSeparatorItem
{
  $rect <10,80,200,120>
  inherited property Bounds = <0,0,220,64>;

  // This example demonstrates how to implement a menu system using Embedded Wizard \
  // Studio.
  // 
  // This concrete GUI component implements the 'Menu Separator Item' component.
  // 
  // To create such menu item we used the 'Menu Separator Item' template found in \
  // the Gallery folder 'Component Templates'.
  // 
  // After adding the template, we adapted it so it has the particular look&feel \
  // of this example.
  // 
  // Similarly, you use the Gallery 'Menu Separator Item' template to add your own \
  // menu item components to your project. Then you can modify the appearance and \
  // the behaviour of the menu item according to your individual design expectations.
  note legend Note
  {
    attr Bounds = <10,150,990,340>;
  }
}

// This component implements a simple menu item. When activating the item, the corresponding \
// menu is closed returning to the superior menu (if any).
$rect <720,170,920,210>
$output false
class ExitMenuItem : Templates::ExitMenuItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       miniumum width for the item.

    */

    // We assume: the item requires space for the caption, 10 pixel margin on
    // its left side and some space for the cross image on the right.
    // Important: perform the calculation without the caption text being evtl.
    // truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 10 + CloseImage.Bounds.w, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      CloseImage.Color   = #FFFFFFFF;
    }

    else if ( isPressed )
    {
      Background.Visible = false;

      CaptionText.Color  = #FFFFFFFF;
      CloseImage.Color   = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Visible = false;
     
      CaptionText.Color  = #FFFFFFFF;
      CloseImage.Color   = #FFFFFFFF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      CloseImage.Color   = #FFFFFFFF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Activation
  note group Note7
  {
    attr Bounds = <930,250,1150,340>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the the item has been activated. Thereupon \
  // the corresponding menu is dismissed returning to the superior menu.
  $rect <940,290,1140,330>
  slot exitMenu
  {
    /*

      The following code dismisses the menu, this menu item belongs to.

      HINT :

      Depending on your design requirements you can modify the DismissDialog() invocation in order
      to override the previously specified animations to hide the affected menu and restore the
      superior menu.

    */

    if ( Owner && Owner.IsCurrentDialog())
      GetRoot().DismissDialog( Owner, null, null, null, null, null, false );
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal exitMenu;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal exitMenu;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal exitMenu;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal exitMenu;
      FlashTimer.Enabled = false;
    }
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,185,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image CloseImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <185,0,220,40>;
    preset Color = #000000FF;
    preset FrameNumber = 9;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

// This component implements a simple menu item. When activating the item a sub menu \
// is shown.
$rect <720,130,920,170>
$output false
class OpenMenuItem : Templates::OpenMenuItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       miniumum width for the item.

    */

    // We assume: the item requires space for the caption, 60 pixel margin on
    // its left side and some space for the arrow image on the right.
    // Important: perform the calculation without the caption text being evtl.
    // truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 70 + ArrowImage.Bounds.w, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      ArrowImage.Color   = #FFFFFFFF;
    }

    else if ( isPressed )
    {
      Background.Visible = false;
     
      CaptionText.Color  = #FFFFFFFF;
      ArrowImage.Color   = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Visible = false;

      CaptionText.Color  = #FFFFFFFF;
      ArrowImage.Color   = #FFFFFFFF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      ArrowImage.Color   = #FFFFFFFF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Activation
  note group Note7
  {
    attr Bounds = <930,250,1150,340>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the the item has been activated. Thereupon \
  // the sub menu is opened and presented.
  $rect <940,290,1140,330>
  slot openSubMenu
  {
    /*

      The following code creates a new instance of the menu GUI component specified in the property
      'SubMenuClass' and presents the component as dialog.

      HINT :

      Depending on your design requirements you can modify the PresentDialog() invocation in order
      to determine the animations to show/hide the menu. Actually, the following implementation
      hides the superior menu when entering the sub-menu. If you don't want it, remove the expression
      'Effects::ShowHideCentered' and replace it by 'null'. In this manner the superiod will remain
      visible while the sub-menu is active.

    */
    if ( Owner && Owner.IsCurrentDialog() && SubMenuClass )
    { var Core::Group asa=(Core::Group)new SubMenuClass;
      GetRoot().PresentDialog(asa, null, null, null, null, Effects::ShowHideCentered, null, null, null, false ); }
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal openSubMenu;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal openSubMenu;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }
  }

  $rect <650,50,850,90>
  onset SubMenuClass
  {
    // Verify, whether the assigned class descends from Core::Group
    if ( value && !(Core::Group)value )
      throw "The specified SubMenuClass does not descend from Core::Group.";

    // Store the new state ...
    pure SubMenuClass = value;
  }

  $rect <450,50,650,90>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the icon in the menu
    Image.Bitmap = value;
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <60,0,193,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <10,0,50,40>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <20,20,160,60>
  object Views::Image ArrowImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <193,0,220,40>;
    preset Color = #000000FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  // The property 'SubMenuClass' determines the menu GUI component to create and \
  // present when the user activates the menu item.
  $rect <650,10,850,50>
  property class SubMenuClass = null;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";

  // The property 'Icon' can refer to a bitmap to show in the menu's caption area.
  $rect <450,10,650,50>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;
}

// This component implements a simple menu item. When activating the item a sub menu \
// is shown providing the user options to select. This item also displays the actually \
// selected option.
$rect <720,90,920,130>
$output false
class OptionItem : Templates::OptionItem
{
  $rect <20,340,220,380>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       miniumum width for the item.

    */

    // We assume: the item requires space for the caption, the icon, the preview
    // text and further margins. Important: perform the calculation without the 
    // caption text being evtl. truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point(( CaptionText.GetContentArea().w + 90 + PreviewText.Bounds.w ), 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      PreviewText.Color  = #FFFFFFFF;;
      ArrowImage.Color   = #FFFFFFFF;
    }

    else if ( isPressed )
    {
      Background.Visible = false;
      
      CaptionText.Color  = #FFFFFFFF;
      PreviewText.Color  = #FFFFFFFF;
      ArrowImage.Color   = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Visible = false;
     
      CaptionText.Color  = #FFFFFFFF;
      PreviewText.Color  = #FFFFFFFF;
      ArrowImage.Color   = #FFFFFFFF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      PreviewText.Color  = #FFFFFFFF;
      ArrowImage.Color   = #FFFFFFFF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Controller events
  note group Note9
  {
    attr Bounds = <470,290,690,380>;
  }

  // Controller events
  note group Note8
  {
    attr Bounds = <240,290,460,380>;
  }

  // Activation
  note group Note7
  {
    attr Bounds = <930,250,1150,340>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // This example demonstrates how to implement a menu system using Embedded Wizard \
  // Studio.
  // 
  // This concrete GUI component implements the 'Option Item' component.
  // 
  // To create such menu item we used the 'Option Item' template found in the Gallery \
  // folder 'Component Templates'.
  // 
  // After adding the template, we adapted it so it has the particular look&feel \
  // of this example.
  // 
  // Similarly, you use the Gallery 'Option Item' template to add your own menu item \
  // components to your project. Then you can modify the appearance and the behaviour \
  // of the menu item according to your individual design expectations.
  note legend Note5
  {
    attr Bounds = <10,400,990,590>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the the item has been activated. Thereupon \
  // the sub menu is opened and presented.
  $rect <940,290,1140,330>
  slot openSubMenu
  {
    /*

      The following code creates a new instance of the menu GUI component specified in the property
      'SubMenuClass' and presents the component as dialog.

      HINT :

      Depending on your design requirements you can modify the PresentDialog() invocation in order
      to determine the animations to show/hide the menu. Actually, the following implementation
      hides the superior menu when entering the sub-menu. If you don't want it, remove the expression
      'Effects::ShowHideCentered' and replace it by 'null'. In this manner the superiod will remain
      visible while the sub-menu is active.

    */
    if ( Owner && Owner.IsCurrentDialog() && SubMenuClass )
      GetRoot().PresentDialog((Core::Group)new SubMenuClass, null, null, null, null, Effects::ShowHideCentered, null, null, null, false );
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <480,330,680,370>
  slot onUpdatePreview
  {
    var string previewString;

    // The preview string is determined by the Radio Menu Item selected actually
    // in the sub menu.
    if ( SubMenuClass )
    {
      // Instantiate temporarily the sub menu and ...
      var Core::Group subMenu = (Core::Group)new SubMenuClass;
      var Core::View  view;
      
      // ... evaluate all views existing in the sub menu searching for a Radio Item
      // matching the actual selection.
      while ( !!(view = subMenu.FindNextView( view, Core::ViewState[ Embedded ])))
      {
        var FishTank::RadioItem radioItem = (FishTank::RadioItem)view;

        // Found a selected radio item? Then query its caption.
        if ( radioItem && (( radioItem.OutletSelector == Selection ) || radioItem.Selected ))
        {
          previewString = radioItem.Caption;
          break;
        }
      }
    }

    // Update the preview text to the caption of the found Radio Item.
    PreviewText.String = previewString;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <250,330,450,370>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the item.
    if ( Outlet != null )
      Selection = Outlet^;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal openSubMenu;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal openSubMenu;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }
  }

  $rect <1050,50,1250,90>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <850,50,1050,90>
  onset Selection
  {
    // Check if the given value differs from the current value
    if ( pure Selection == value )
      return;

    // Store the new state ...
    pure Selection = value;

    // When changing the selection, trigger an update of the preview text
    postsignal onUpdatePreview;
  }

  $rect <650,50,850,90>
  onset SubMenuClass
  {
    // Verify, whether the assigned class descends from Core::Group
    if ( value && !(Core::Group)value )
      throw "The specified SubMenuClass does not descend from Core::Group.";

    // Check if the given value differs from the current value
    if ( pure SubMenuClass == value )
      return;

    // Store the new state ...
    pure SubMenuClass = value;

    // When changing the sub menu class, trigger an update of the preview text.
    // Possibly, the new sub menu contains differnt strings for the options.
    postsignal onUpdatePreview;
  }

  $rect <450,50,650,90>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the icon in the menu
    Image.Bitmap = value;
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <60,0,110,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <10,0,50,40>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <20,20,160,60>
  object Views::Text PreviewText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <110,0,193,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Option";
    preset Font = Resources::FontSmall;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image ArrowImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <193,0,220,40>;
    preset Color = #000000FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  // The property 'Outlet' can refer to any other 'int32' property the item should \
  // remain synchronized with. When the user selects the item, the affected property \
  // is automatically updated to the value found in the property @OutletSelector. \
  // On the other hand, when the referred property is modified by another one, the \
  // item is automatically notified to remain in sync with the property. The item \
  // appears selected, when the referred property has the value equal to @OutletSelector.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the item represents the 'View' and the property referred via 'Outlet' can \
  // be seen as a part of the 'Model'.
  $rect <1050,10,1250,50>
  property ^int32 Outlet = null;

  // The property 'Selection' stores a value representing the current selection.
  $rect <850,10,1050,50>
  property int32 Selection = 0;

  // The property 'SubMenuClass' determines the menu GUI component to create and \
  // present when the user activates the menu item. This menu should consist of Radio \
  // Menu Items.
  $rect <650,10,850,50>
  property class SubMenuClass = null;

  // The property 'Icon' can refer to a bitmap to show in the menu's caption area.
  $rect <450,10,650,50>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

// This component implements a simple menu item.
$rect <720,50,920,90>
$output false
class MenuItem : Templates::MenuItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       miniumum width for the item.

    */

    // We assume: the item requires space for the caption and 70 pixel margin on
    // the left and on the right of the caption. Important: perform the calculation
    // without the caption text being evtl. truncated and replaced by an ellipsis
    // sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 70, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      Image.Opacity      = 128;
    }

    else if ( isPressed )
    {
      Background.Visible = false;
      Background.Color   = #AEAEAEFF;
      CaptionText.Color  = #FFFFFFFF;
      Image.Opacity      = 255;
    }

    else if ( isSelected )
    {
      Background.Visible = false;
      Background.Color   = #CECECEFF;
      CaptionText.Color  = #FFFFFFFF;
      Image.Opacity      = 255;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Visible = false;
      CaptionText.Color  = #FFFFFFFF;
      Image.Opacity      = 255;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <450,50,650,90>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the icon in the menu
    Image.Bitmap = value;
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,39>;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <60,0,210,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <10,0,50,40>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated (pressed and released) the item. Thereupon \
  // the method's logic will be executed.
  $rect <650,10,850,50>
  property slot OnActivate = null;

  // The property 'Icon' can refer to a bitmap to show in the menu's caption area.
  $rect <450,10,650,50>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

// This component implements a generic menu.
$rect <520,50,720,90>
$output false
class Menu : Templates::Menu
{
  $rect <0,710,200,750>
  inherited property Bounds = <0,0,271,480>;

  $rect <590,420,790,460>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    // This method is called always when something has changed in the
    // layout of the menu. In particular when items are added, removed,
    // hidden or shown. It is also called when the menu itself changes
    // its size.

    // In our template we want the menu to adjust its size automatically
    // to the number of available items. Doing this however directly in
    // context of the UpdateLayout() method would cause the UpdateLayout()
    // method to be executed recursively.

    // Therefore, we delay the adjust operation by using the 'postsignal'.
    // The adjust operation takes place in the slot method 'autoResize'.

    //postsignal autoResize;
  }

  $rect <290,430,490,470>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the menu.
    //
    // isEnabled --> the menu can react to user inputs.
    // isModal   --> the menu is actually modal (it grabs all user inputs).
    // isFocused --> the menu can receive keyboard events.
    //
    var bool isEnabled = aState.contains( Core::ViewState[ Enabled ]);
    var bool isModal   = aState.contains( Core::ViewState[ Modal   ]);
    var bool isFocused = aState.contains( Core::ViewState[ Focused ]);


    /*

      TO DO:

      Depending on your menu design, you have surely added some new views
      to your menu. In the below code you should update the properties of
      these views. For example, when your menu has two images to appear
      exclusively for a focused or not focused menu, following can be done:

        imageFocused.Visible    =  isFocused;
        imageNotFocused.Visible = !isFocused;

      Depending on the state of the menu, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the menu
      (e.g. 'isFocused') with its preceding state (e.g. variable 'focused').

      Assuming you have already added to your menu component a new effect
      member, named it 'focusedEffect' and configured it to animate e.g. the
      opacity of an image within the menu. Then following is sufficient to
      trigger the animation:

        if ( isFocused && !focused )
        {
          focusedEffect.Reversed = false;
          focusedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          focusedEffect.Reversed = true;
          focusedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      CaptionText.Color = #FFFFFFFF;
    }

    else if ( isFocused )
    {
      CaptionText.Color = #FFFFFFFF;
    }

    // Enabled but actually not focused for user interaction.
    else
    {
      CaptionText.Color = #FFFFFFFF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // focused <<-->> not focused transition.
    enabled = isEnabled;
    focused = isFocused;
    modal   = isModal;
  }

  // Layout management
  note group Note3
  {
    attr Bounds = <580,370,800,500>;
  }

  // State management
  note group Note2
  {
    attr Bounds = <280,390,500,600>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <-10,550,210,680>;
  }

  // This variable stores the current state of the menu. Please see the comments \
  // inside UpdateViewState().
  $rect <290,550,490,590>
  var bool focused;

  // This variable stores the current state of the menu. Please see the comments \
  // inside UpdateViewState().
  $rect <290,510,490,550>
  var bool modal;

  // This variable stores the current state of the menu. Please see the comments \
  // inside UpdateViewState().
  $rect <290,470,490,510>
  var bool enabled;

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <0,590,200,630>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onPressKey;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <0,630,200,670>
  slot onPressKey
  {
    var Core::Direction dir  = Core::Direction.None;
    var Core::View      item = Focus;

    // Determine the direction to look for other items to select
    switch ( KeyHandler.Code )
    {
      case Core::KeyCode.Left  : dir = Core::Direction.Left;
      case Core::KeyCode.Right : dir = Core::Direction.Right;
      case Core::KeyCode.Up    : dir = Core::Direction.Top;
      case Core::KeyCode.Down  : dir = Core::Direction.Bottom;
      default:;
    }

    // Look for the neighbor item accordingly the determined direction
    item = FindViewInDirection( item, dir, Core::ViewState[ Enabled, Focusable ]);

    // If found -> pass the focus to it
    // In case of large menus - scroll to the item with an animation effect
    if ( item != null )
    {
      Focus = item;

      // Prepare the animation effect. If you don't want the scroll animation,
      // just remove the following 3 lines and pass 'null' in the EnsureVisible()
      // method instead of 'effect'.
      var Effects::PointEffect effect = new Effects::PointEffect;

      effect.Timing        = Effects::Timing.FastIn_EaseOut;
      effect.CycleDuration = 100;

      // Scroll to the item
      Outline.EnsureVisible( item, true, effect, null );
    }
  }

  $rect <910,70,1110,110>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the icon in the menu
    Image.Bitmap = value;
  }

  $rect <710,70,910,110>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the menu
    CaptionText.String = value;

    // Changing the caption can also affect the width of the
    // menu itself. Therefore trigger the routine to recalculate
    // the menu size
    InvalidateLayout();
  }

  $rect <20,20,160,60>
  object Views::Frame Background
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <-6,-6,266,473>;
    preset Bitmap = FishTank::MenuPageBackground;
  }

  $rect <20,20,160,60>
  object Views::Rectangle CaptionSeparator
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <6,71,230,73>;
    preset Color = #C8C8C8FF;
  }

  // This is a slide gesture handler. It allows the user to scroll the items within \
  // a large menu by touching the menu with the mouse or with the finger on a touch \
  // screen.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,73,258,464>;
    preset SnapNext = <0,30>;
    preset SlideHorz = false;
    preset Friction = 0.01;
  }

  // This is an outline view to group and scroll the items together.
  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,73,258,467>;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.TopToBottom;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <16,29,227,65>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Menu";
    preset Font = Resources::FontMedium;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <218,27,249,67>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  // The property 'Icon' can refer to a bitmap to show in the menu's caption area.
  $rect <910,30,1110,70>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;

  // The property 'Caption' stores the text to display within the menu. 
  $rect <710,30,910,70>
  property string Caption = "Menu";
}

$rect <270,90,490,130>
autoobject FishTank::DeviceClass Device;

$rect <270,50,490,90>
$output false
class DeviceClass : Templates::DeviceClass
{
  // This property reflects the current contrast value in the range 0 .. 100.
  $rect <210,10,410,50>
  property int32 Contrast = 50;

  $rect <410,10,610,50>
  onset Contrast
  {
    // The property doesn't change -> nothing to do.
    if ( pure Contrast == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Contrast = value;

    $if $prototyper
      trace "Change contrast to", value;
    $endif

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Contrast;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,10,210,50>
  $output true
  method void UpdateContrast( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Contrast )
    {
      // Remember the new value in the internal memory of the property.
      pure Contrast = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Contrast;
    }
  }

  // This property reflects the current brightness value in the range 0 .. 100.
  $rect <210,50,410,90>
  property int32 Brightness = 100;

  $rect <410,50,610,90>
  onset Brightness
  {
    // The property doesn't change -> nothing to do.
    if ( pure Brightness == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Brightness = value;

    $if $prototyper
      trace "Change brightness to", value;
    $endif

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Brightness;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,50,210,90>
  $output true
  method void UpdateBrightness( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Brightness )
    {
      // Remember the new value in the internal memory of the property.
      pure Brightness = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Brightness;
    }
  }

  // This property reflects the current colour value in the range 0 .. 100.
  $rect <210,90,410,130>
  property color Color = #FFFFFF00;

  $rect <410,90,610,130>
  onset Color
  {
    // The property doesn't change -> nothing to do.
    if ( pure Color == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Color = value;

    $if $prototyper
      trace "Change color to", value;
    $endif

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Color;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <10,90,210,130>
  $output true
  method void UpdateColor( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Color )
    {
      // Remember the new value in the internal memory of the property.
      pure Color = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Color;
    }
  }

  // This property reflects the current contrast value in the range 0 .. 100.
  $rect <209,149,409,189>
  property int32 Temperature = 22;

  $rect <409,149,609,189>
  onset Temperature
  {
    // The property doesn't change -> nothing to do.
    if ( pure Temperature == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Temperature = value;

    $if $prototyper
      trace "Change temperature to", value;
    $endif

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Temperature;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <9,149,209,189>
  $output true
  method void UpdateTemperature( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Temperature )
    {
      // Remember the new value in the internal memory of the property.
      pure Temperature = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Temperature;
    }
  }

  $rect <39,199,239,239>
  property int32 SettingNo = 0;

  $rect <239,199,439,239>
  onset SettingNo
  {
    /* limit to three settings */
    if ( value > 2 )
      value = 2;
    if ( value < 0 )
      value = 0;


    // The property doesn't change -> nothing to do.
    if ( pure SettingNo == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure SettingNo = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^SettingNo;
  }

  $rect <660,100,860,140>
  property int32 CurrentBackground = 1;

  $rect <860,100,1080,140>
  onset CurrentBackground
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentBackground == value )
      return;

    // Remember the property's new value.
    pure CurrentBackground = value;

    notifyobservers ^CurrentBackground;
  }
}

$rect <60,190,240,230>
$output false
$multilingual true
class TemperatureMenu : FishTank::Menu
{
  $rect <10,490,210,530>
  inherited property Bounds = <0,0,265,480>;

  $rect <540,80,740,120>
  inherited property Icon = FishTank::TemperaturePicture;

  $rect <550,30,750,70>
  inherited property Caption = FishTank::TM_Caption;

  $rect <20,20,160,60>
  inherited object SlideTouchHandler
  {
    preset Bounds = <-4,0,274,480>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,0,263,479>;
  }

  $rect <20,20,160,60>
  inherited object CaptionSeparator
  {
    preset Bounds = <12,64,254,68>;
  }

  $rect <20,20,160,60>
  inherited object Outline
  {
    preset Bounds = <12,74,249,457>;
  }

  $rect <20,20,160,60>
  inherited object CaptionText
  {
    preset Bounds = <22,24,225,57>;
  }

  $rect <20,20,160,60>
  inherited object Image
  {
    preset Bounds = <213,21,244,58>;
  }

  $rect <20,20,160,60>
  object FishTank::TemperatureDisplay TempDisplay
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <23,81,240,145>;
  }

  $rect <20,20,160,60>
  object FishTank::SliderItem TempSlider
  {
    preset Bounds = <24,133,244,173>;
    preset Outlet = ^FishTank::Device.Temperature;
    preset MaxValue = 32;
    preset CurrentValue = 22;
  }

  $rect <20,20,160,60>
  object FishTank::TemperatureNote TemperatureNote
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <1,182,266,295>;
  }

  $rect <20,20,160,60>
  object FishTank::MenuSeparatorItem MenuSeparatorItem
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz];
    preset Bounds = <21,294,241,420>;
  }

  $rect <20,20,160,60>
  object FishTank::ExitMenuItem ExitMenuItem
  {
    preset Bounds = <29,415,249,455>;
    preset Caption = FishTank::LM_Back;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Background
  $member CaptionSeparator
  $member SlideTouchHandler
  $member Outline
  $member CaptionText
  $member Image
  $member Icon
  $member Caption
  $member TempDisplay
  $member TempSlider
  $member TemperatureNote
  $member MenuSeparatorItem
  $member ExitMenuItem
}

$rect <60,150,240,190>
$output false
$multilingual true
class LightMenu : FishTank::Menu
{
  $rect <310,420,508,460>
  inherited property Bounds = <0,0,265,480>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,0,263,479>;
  }

  $rect <520,70,720,110>
  inherited property Icon = FishTank::LightPicture;

  $rect <530,20,730,60>
  inherited property Caption = FishTank::LM_Caption;

  $rect <20,20,160,60>
  inherited object CaptionSeparator
  {
    preset Bounds = <12,64,254,68>;
  }

  $rect <20,20,160,60>
  inherited object Outline
  {
    preset Bounds = <12,74,249,457>;
  }

  $rect <20,20,160,60>
  inherited object CaptionText
  {
    preset Bounds = <22,24,225,57>;
  }

  $rect <20,20,160,60>
  inherited object Image
  {
    preset Bounds = <213,21,244,58>;
  }

  $rect <20,20,160,60>
  object FishTank::MenuItem BrightnessItem
  {
    preset Bounds = <12,80,241,119>;
    preset Icon = FishTank::BrightnessPicture;
    preset Caption = FishTank::LM_Brightness;
  }

  $rect <20,20,160,60>
  inherited object SlideTouchHandler
  {
    preset Bounds = <-13,75,267,475>;
  }

  // The property 'Layout' controls the automatic arrangement of the view. It specifies \
  // a set of alignment constraints and determines whether the view can change its \
  // size. It is used primarily to re-arrange the view after its @Owner has been \
  // resized. It also controls the arrangement of the view if it has been embedded \
  // within a Core::Outline.
  // The constraints AlignToLeft, AlignToRight, AlignToTop and AlignToBottom determine \
  // whether the view is left, right, top or bottom aligned. If active, the view \
  // will try to remain a constant distance to the corresponding edge of its owner. \
  // In contrast all not explicitly aligned edges are moved proportionally to the \
  // size modification of the views owner.
  // The constraints ResizeVert and ResizeHorz determine the resize behavior of the \
  // view in response to the size modification of its owner. Views with these constraints \
  // disabled always will keep their size unchanged. In conflict cases when the alignment \
  // and resize constraints do contradict, the view will maintain its size and will \
  // be pulled into the middle area resulting by the alignment constraints.
  // In case of views automatically arranged in rows or columns within a Core::Outline, \
  // the alignment constraints determine the vertical or horizontal alignment of \
  // the view within the corresponding row or column. The resize constraints in this \
  // case enable the view to fill the entire height of a column or the entire width \
  // of a row.
  $rect <520,120,720,160>
  property Core::Layout Layout1 = Core::Layout[AlignToLeft, AlignToTop];

  $rect <529,300,729,340>
  slot onShowStyle
  {
    // Leave this dialog and show another one
    if ( IsDialog( false ))
      Owner.SwitchToDialog( new FishTank::StyleScreen, Effects::SlideDownCentered, Effects::SlideUpCentered, null, null, Effects::SlideDownCentered, null, null, null, null, false );
  }

  $rect <540,199,740,239>
  slot ChangeRed
  {
    FishTank::Device.Color =#b83dba88;

  }

  $rect <535,240,735,280>
  slot ChangeBlue
  {
    FishTank::Device.Color =#45E7FF88;
  }

  $rect <20,20,160,60>
  object FishTank::SliderItem BrightnessSlider
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <13,126,241,166>;
    preset OnChange = null;
    preset Outlet = ^FishTank::Device.Brightness;
  }

  $rect <310,20,510,60>
  property int32 Color;

  $rect <310,70,510,110>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <310,119,510,159>
  onget Color
  {
    return pure Color;
  }

  $rect <20,20,160,60>
  object FishTank::MenuItem ContrastItem
  {
    preset Bounds = <15,159,244,198>;
    preset Icon = FishTank::ContrastPicture;
    preset Caption = FishTank::LM_Contrast;
  }

  $rect <20,20,160,60>
  object FishTank::SliderItem ContrastSlider
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <17,195,245,235>;
    preset Outlet = ^FishTank::Device.Contrast;
  }

  $rect <20,20,160,60>
  object FishTank::RadioItem1 PurpleRadio
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <18,258,247,298>;
    preset OnSelect = ChangeRed;
    preset OutletSelector = 1;
    preset Outlet = ^Color;
    preset Selected = true;
    preset Icon = FishTank::RedColor;
    preset Caption = "";
  }

  $rect <530,350,730,390>
  slot ChangeWhite
  {
    FishTank::Device.Color =#ffffff00;
  }

  $rect <20,20,160,60>
  object FishTank::RadioItem1 BlueRadio
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <18,290,255,330>;
    preset OnSelect = ChangeBlue;
    preset OutletSelector = 2;
    preset Outlet = ^Color;
    preset Selected = true;
    preset Icon = FishTank::BlueColor;
    preset Caption = "Colors";
  }

  $rect <20,20,160,60>
  object FishTank::RadioItem1 WhiteRadio
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <18,322,217,362>;
    preset OnSelect = ChangeWhite;
    preset OutletSelector = 3;
    preset Outlet = ^Color;
    preset Selected = true;
    preset Icon = FishTank::WhireColor;
    preset Caption = "";
  }

  $rect <20,20,160,60>
  object FishTank::MenuSeparatorItem MenuSeparatorItem
  {
    preset Bounds = <18,374,238,438>;
  }

  $rect <20,20,160,60>
  object FishTank::ExitMenuItem ExitMenuItem
  {
    preset Bounds = <22,411,242,451>;
    preset Caption = FishTank::TM_Back;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Bounds
  $member Background
  $member CaptionSeparator
  $member SlideTouchHandler
  $member Outline
  $member CaptionText
  $member Image
  $member Icon
  $member Caption
  $member BrightnessItem
  $member Layout1
  $member onShowStyle
  $member ChangeRed
  $member ChangeBlue
  $member BrightnessSlider
  $member Color
  $member OnSetColor
  $member OnGetColor
  $member ContrastItem
  $member ContrastSlider
  $member PurpleRadio
  $member ChangeWhite
  $member BlueRadio
  $member WhiteRadio
  $member MenuSeparatorItem
  $member ExitMenuItem
}

$rect <60,110,240,150>
$output false
$multilingual true
class MainPage : FishTank::Menu
{
  $rect <450,120,630,160>
  inherited property Bounds = <0,0,265,480>;

  $rect <440,70,640,110>
  inherited property Icon = FishTank::MainMenuPicture;

  $rect <440,30,640,70>
  inherited property Caption = FishTank::MM_Caption;

  $rect <20,20,160,60>
  object FishTank::OpenMenuItem LightsItem
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <12,80,241,119>;
    preset SubMenuClass = FishTank::LightMenu;
    preset Caption = FishTank::MM_LightSettings;
    preset Icon = FishTank::LightPicture;
  }

  $rect <20,20,160,60>
  object FishTank::OpenMenuItem TempItem
  {
    preset Bounds = <14,120,241,159>;
    preset SubMenuClass = FishTank::TemperatureMenu;
    preset Caption = FishTank::MM_TemperatureSettings;
    preset Icon = FishTank::TemperaturePicture;
  }

  $rect <20,20,160,60>
  object FishTank::MenuSeparatorItem SeparatorItem1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz];
    preset Bounds = <15,161,246,429>;
  }

  $rect <20,20,160,60>
  object FishTank::ExitMenuItem ExitItem
  {
    preset Bounds = <17,417,246,454>;
    preset Caption = FishTank::MM_Close;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,263,479>;
  }

  $rect <20,20,160,60>
  inherited object CaptionSeparator
  {
    preset Bounds = <12,64,254,68>;
  }

  $rect <20,20,160,60>
  inherited object SlideTouchHandler
  {
    preset Bounds = <14,74,253,460>;
  }

  $rect <20,20,160,60>
  inherited object Outline
  {
    preset Bounds = <12,74,249,457>;
  }

  $rect <20,20,160,60>
  inherited object CaptionText
  {
    preset Bounds = <22,24,225,57>;
  }

  $rect <20,20,160,60>
  inherited object Image
  {
    preset Bounds = <213,21,244,58>;
  }

  $rect <430,-19,630,21>
  inherited property Layout = Core::Layout[AlignToLeft, AlignToTop];

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Layout
  $member Bounds
  $member Background
  $member CaptionSeparator
  $member SlideTouchHandler
  $member Outline
  $member CaptionText
  $member Image
  $member Icon
  $member Caption
  $member LightsItem
  $member TempItem
  $member SeparatorItem1
  $member ExitItem
}

$rect <1280,190,1480,230>
$output false
resource Resources::Bitmap MenuBackground
{
  attr bitmapfile FileName = .\Resources\AdobeStock_198247162.jpg;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This is the root component of the entire GUI application.
$rect <30,60,210,100>
$output false
class Application : Core::Root
{
  $rect <-410,450,-220,490>
  inherited property Bounds = <0,0,272,480>;

  // The variable maintains the controller object alive durring the entire runtime. \
  // Without the variable, the controller will be deinitialized if it is not used.
  $rect <-410,350,-220,390>
  $output true
  var FishTank::DeviceClass debviceObject = FishTank::Device;

  $rect <-420,250,-230,290>
  slot openMainMenu
  {
    // In order to avoid race conditions ignore the push button events if there
    // is already a menu presented


    // Create a new instance of the menu component
    var FishTank::MainPage menu = new FishTank::MainPage;
                         // Update the appearance of the background according to actual setting stored in the device

    postsignal onUpdateBackground;

    // ... and present it by using a fade-in transition
    PresentDialog( menu, FishTank::SlideTransition, null, null, null, null, null, null, null, false );


  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <-5,-7,273,488>;
    preset Bitmap = FishTank::MenuBackground;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <20,14,50,44>;
    preset OnActivate = openMainMenu;
    preset Icon = FishTank::IconButton;
    preset Appearance = FishTank::IconButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay TempDispaly
  {
    preset StackingPriority = 0;
    preset Bounds = <28,218,92,248>;
    preset Outlet = ^FishTank::Device.Temperature;
    preset Unit = "°C";
    preset Precision = 1;
    preset Appearance = FishTank::ValueDisplay_Small;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Bounds = <2,165,147,279>;
    preset Bitmap = FishTank::Shadow2;
  }

  $rect <20,20,160,60>
  object Views::Text TempText
  {
    preset Bounds = <8,178,122,223>;
    preset String = "Temp";
    preset Font = Resources::FontMedium;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text LightsText
  {
    preset Bounds = <143,176,257,221>;
    preset String = "Lights";
    preset Font = Resources::FontMedium;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton LightsDayButton
  {
    preset Bounds = <163,207,228,234>;
    preset OutletSelector = 100;
    preset Outlet = ^FishTank::Device.Brightness;
    preset Selected = true;
    preset OnSelect = null;
    preset Label = "Day";
    preset Appearance = WidgetSet::RadioButton_Small;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton LightsNightButton
  {
    preset Bounds = <163,224,243,269>;
    preset OutletSelector = 0;
    preset Outlet = ^FishTank::Device.Brightness;
    preset Selected = false;
    preset OnSelect = null;
    preset Label = "Night";
    preset Appearance = WidgetSet::RadioButton_Small;
  }

  $rect <20,20,160,60>
  object Views::Text TimeText
  {
    preset Bounds = <147,18,266,48>;
    preset String = "00:00";
    preset Font = Resources::FontLarge;
    preset Color = #FFFFFFFF;
  }

  $rect <-420,300,-220,340>
  slot onTimer
  {
    TimeText.String = ( new Core::Time ).CurrentTime.Format( "%H:%M" );
  }

  $rect <-410,400,-210,440>
  object Core::Timer Timer
  {
    preset OnTrigger = onTimer;
    preset Begin = 1;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object WidgetSet::VerticalValueBar VerticalValueBar
  {
    preset Bounds = <99,187,119,252>;
    preset Outlet = ^FishTank::Device.Temperature;
    preset MaxValue = 35;
    preset CurrentValue = 22;
    preset Appearance = WidgetSet::VerticalValueBar_Small;
  }

  $rect <20,20,160,60>
  object Views::Image Image5
  {
    preset Bounds = <126,165,271,279>;
    preset Bitmap = FishTank::Shadow2;
  }

  $rect <20,20,160,60>
  object Views::Image Image6
  {
    preset Bounds = <126,165,271,279>;
    preset Bitmap = FishTank::Shadow2;
  }

  $rect <20,20,160,60>
  object Views::Image Image4
  {
    preset Bounds = <2,165,147,279>;
    preset Bitmap = FishTank::Shadow2;
  }

  $rect <20,20,160,60>
  object FishTank::Background Background
  {
    preset Bounds = <27,70,247,161>;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <410,379,610,419>
  slot onUpdateBackground
  {
    // Update the appearance of the background according to actual setting stored in the device
    Background.CurrentBackground = FishTank::Device.CurrentBackground;

  }

  $rect <410,330,610,370>
  object Core::PropertyObserver PropertyObserver
  {
    preset OnEvent = onUpdateBackground;
    preset Outlet = ^FishTank::Device.CurrentBackground;
  }

  $rect <410,230,610,270>
  slot onShowKeyboard
  {
    // Place the keyboard at the given position
    VirtualKeyboard1.Bounds.origin = <3,375>;

    // Activate the keyboard
    VirtualKeyboard = VirtualKeyboard1;



  }

  $rect <410,280,610,320>
  slot onHideKeyboard
  {
    // Move the keyboard below the bottom screen edge
    VirtualKeyboard1.Bounds.origin.y = Bounds.y2;

    // Deactivate the keyboard
    VirtualKeyboard = null;

    KeyboardToggle.Checked = false;

  }

  $rect <20,20,160,60>
  object FishTank::Editor Editor
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <123,282,239,351>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "Reminders";
    preset Color = #FFFFFFFF;
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton KeyboardToggle
  {
    preset StackingPriority = 0;
    preset Bounds = <127,340,289,390>;
    preset OnSwitchOn = onShowKeyboard;
    preset OnSwitchOff = onHideKeyboard;
    preset Label = "Keyboard";
    preset Appearance = WidgetSet::CheckBox_Small;
  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <830,120,1030,160>
  property rect Bounds1 = <0,0,800,560>;

  // The property 'Focus' selects the view to which the component should forward \
  // all keyboard events. If a keyboard event arrives to the component, the event \
  // is first propagated to this selected view before the component can handle it.
  // In a hierarchy of nested components, their @Focus properties will establish \
  // a kind of focus path which leads directly from the application object to the \
  // current keyboard event receiver view. In this context all views along this focus \
  // path are 'focused' and able to react to keyboard events.
  // The @Focus property affects the state of the selected view. The view will obtain \
  // the state Core::ViewState.Selected. Views really belonging to the focus path \
  // are additionally signed with the state Core::ViewState.Focused. These states \
  // can be evaluated in the views implementation of the @UpdateViewState() method. \
  // For example, the method can highlight the view if it is focused.
  // Please note, it is not possible to select a view which is not able to react \
  // to keyboard events. Whether a view is able or not is determined by its property \
  // @Enabled. If this property changes for the currently selected view, the framework \
  // will automatically select other able sibling view.
  $rect <830,80,1030,120>
  property Core::View Focus1 = Editor;

  $rect <20,20,160,60>
  object FishTank::VirtualKeyboard VirtualKeyboard1
  {
    preset Bounds = <2,487,268,593>;
    preset OnHide = onHideKeyboard;
  }

  $rect <20,20,160,60>
  object Views::Image Image7
  {
    preset Bounds = <65,253,300,404>;
    preset Bitmap = FishTank::Shadow;
  }

  $rect <20,20,160,60>
  object Views::Image Image8
  {
    preset Bounds = <65,253,300,404>;
    preset Bitmap = FishTank::Shadow;
  }

  $rect <20,20,160,60>
  object Views::Image Image9
  {
    preset Bounds = <65,253,300,404>;
    preset Bitmap = FishTank::Shadow;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton ThirdBg
  {
    preset StackingPriority = 0;
    preset Bounds = <27,368,96,410>;
    preset Outlet = ^FishTank::Device.CurrentBackground;
    preset Selected = true;
    preset IconFrame = 0;
    preset Icon = FishTank::BackgroundPreview;
    preset Appearance = RadioButtonConfig;
  }

  $rect <410,179,610,219>
  object WidgetSet::RadioButtonConfig RadioButtonConfig
  {
    preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset FaceOnActive = FishTank::BackgroundFrame;
    preset FaceOnFocused = FishTank::BackgroundFrame;
    preset FaceOnDefault = FishTank::BackgroundFrame;
    preset FaceOffTintActive = #404040FF;
    preset FaceOffTintFocused = #404040FF;
    preset FaceOffTintDisabled = #404040FF;
    preset FaceOffTintDefault = #404040FF;
    preset FaceOffActive = FishTank::BackgroundFrame;
    preset FaceOffFocused = FishTank::BackgroundFrame;
    preset FaceOffDefault = FishTank::BackgroundFrame;
    preset WidgetMaxSize = <0,0>;
    preset WidgetMinSize = <0,0>;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton SecondBg
  {
    preset StackingPriority = 0;
    preset Bounds = <28,322,97,364>;
    preset OutletSelector = 2;
    preset Outlet = ^FishTank::Device.CurrentBackground;
    preset IconFrame = 2;
    preset Icon = FishTank::BackgroundPreview;
    preset Appearance = RadioButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::RadioButton FirstBg
  {
    preset StackingPriority = 0;
    preset Bounds = <28,277,97,319>;
    preset OutletSelector = 1;
    preset Outlet = ^FishTank::Device.CurrentBackground;
    preset IconFrame = 1;
    preset Icon = FishTank::BackgroundPreview;
    preset Appearance = RadioButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Image Rectangle
  {
    preset Bounds = <27,70,247,161>;
    preset Bitmap = FishTank::Rectangle;
    preset Visible = true;
  }

  $rect <419,80,619,120>
  inherited method Init()
  {
    attachobserver OnLightChange, ^FishTank::Device.Brightness;
    postsignal OnLightChange;

  }

  $rect <640,330,840,370>
  object Core::PropertyObserver PropertyObserver1
  {
    preset OnEvent = OnLightChange;
    preset Outlet = ^FishTank::Device.Brightness;
  }

  $rect <640,379,840,419>
  slot OnLightChange
  {
    if (FishTank::Device.Brightness>50)
    Rectangle.Opacity=90-FishTank::Device.Brightness;
    else Rectangle.Opacity=150-FishTank::Device.Brightness;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member debviceObject
  $member openMainMenu
  $member Image
  $member MenuButton
  $member TempDispaly
  $member Image3
  $member TempText
  $member LightsText
  $member LightsDayButton
  $member LightsNightButton
  $member TimeText
  $member onTimer
  $member Timer
  $member VerticalValueBar
  $member Image5
  $member Image6
  $member Image4
  $member Background
  $member onUpdateBackground
  $member PropertyObserver
  $member onShowKeyboard
  $member onHideKeyboard
  $member Editor
  $member KeyboardToggle
  $member Bounds1
  $member Focus1
  $member VirtualKeyboard1
  $member Image7
  $member Image8
  $member Image9
  $member ThirdBg
  $member RadioButtonConfig
  $member SecondBg
  $member FirstBg
  $member Rectangle
  $member PropertyObserver1
  $member OnLightChange
}

// The global autoobject FishTank::FadeInOutCentered represents the fade-in/out operation \
// affecting the opacity of a given GUI component. When using the transition for \
// the fade-in operation, the GUI component is automatically arranged to appear centered \
// within the area of its owner component. This transition is thus ideal wherever \
// one GUI component should smoothly appear or disappear in context of another component. \
// The duration of the transition is configured per default to take 500 ms.
// This object exists for your convenience permitting you to simply refer the transition \
// wherever it is required in your implementation without having to take care of \
// the creation and configuration of the object. If you require the transition to \
// run with other configuration (e.g. other timing parameters), create a copy of \
// this object and adapt its properties accordingly.
$rect <0,330,250,370>
$output false
autoobject Effects::FadeInOutTransition FadeInOutCentered
{
  preset Alignment = Effects::DialogAlignment[AlignHorzCenter, AlignVertCenter];
}

$rect <359,540,539,580>
$output false
const string TM_Temperature =
(
  Default = "Temperature";
  German = "Kontrast";
);

// This autoobject provides the default customization for the 'value display' widget \
// (WidgetSet::ValueDisplay) in its small size variant. Widgets using this configuration \
// display the value and unit aligned at the right widget edge.
$rect <750,439,1050,479>
$output false
autoobject WidgetSet::ValueDisplayConfig ValueDisplay_Small
{
  preset ValueMarginRight = 7;
  preset ValueColorNegative = #ffffffFF;
  preset ValueColorPositive = #FFFFFFFF;
  preset ValueAlignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
  preset ValueFont = Resources::FontMedium;
  preset UnitColorNegative = #3AC944FF;
  preset UnitColorPositive = #C4C6C9FF;
  preset UnitAlignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
  preset UnitFont = Resources::FontMedium;
  preset FormatPlusSign = "";
  preset Layout = WidgetSet::ValueDisplayLayout.AlignValueLeftToUnit;
  preset WidgetMinSize = <40,22>;
}

$rect <750,480,1050,520>
$output false
autoobject WidgetSet::PushButtonConfig PushButton_Small
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorFocused = #808080FF;
  preset LabelColorDisabled = #FFFFFFFF;
  preset LabelColorDefault = #808080FF;
  preset IconTintActive = #FFFFFFFF;
  preset IconTintFocused = #808080FF;
  preset IconTintDisabled = #FFFFFFFF;
  preset IconTintDefault = #808080FF;
  preset LabelFont = Resources::FontMedium;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop];
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 1;
  preset FaceActive = FishTank::OrangeButtonSmall;
  preset FaceFocused = FishTank::OrangeButtonSmall;
  preset FaceDisabled = FishTank::OrangeButtonSmall;
  preset FaceDefault = FishTank::OrangeButtonSmall;
  preset WidgetMaxSize = <120,45>;
  preset WidgetMinSize = <120,45>;
}

$rect <750,519,1050,559>
$output false
autoobject WidgetSet::RadioButtonConfig RadioButton
{
  preset LabelMarginLeft = 50;
  preset IconMarginLeft = 50;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelOnFont = Resources::FontMedium;
  preset LabelOffFont = Resources::FontMedium;
  preset IconAlignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop];
  preset FaceOnFrameActive = 7;
  preset FaceOnFrameFocused = 5;
  preset FaceOnFrameDisabled = 1;
  preset FaceOnFrameDefault = 3;
  preset FaceOnActive = FishTank::OrangeRadioButton;
  preset FaceOnFocused = FishTank::OrangeRadioButton;
  preset FaceOnDisabled = FishTank::OrangeRadioButton;
  preset FaceOnDefault = FishTank::OrangeRadioButton;
  preset FaceOffFrameActive = 6;
  preset FaceOffFrameFocused = 4;
  preset FaceOffFrameDisabled = 0;
  preset FaceOffFrameDefault = 2;
  preset FaceOffActive = FishTank::OrangeRadioButton;
  preset FaceOffFocused = FishTank::OrangeRadioButton;
  preset FaceOffDisabled = FishTank::OrangeRadioButton;
  preset FaceOffDefault = FishTank::OrangeRadioButton;
  preset WidgetMinSize = <45,45>;
}

// This autoobject provides the default customization for the 'vertical value bar' \
// widget (WidgetSet::VerticalValueBar) in its medium size variant.
$rect <750,640,1050,680>
$output false
autoobject WidgetSet::VerticalValueBarConfig VerticalValueBar_Small
{
  preset SwingElastic = true;
  preset SwingDuration = 800;
  preset CoverTint = #FF1DB9FF;
  preset NeedleTint = #FF1DB9FF;
  preset TrackAboveTint = #FF1DB9FF;
  preset TrackAboveFrame = 0;
  preset TrackAbove = FishTank::OrangeVertSliderTrackSmall;
  preset TrackBelowTint = #FF1DB9FF;
  preset TrackBelowFrame = 1;
  preset TrackBelow = FishTank::OrangeVertSliderTrackSmall;
  preset FaceTint = #FF1DB9FF;
  preset Face = WidgetSet::VerticalSliderTrackLarge;
  preset WidgetMaxSize = <21,180>;
  preset WidgetMinSize = <10,70>;
}

// This autoobject provides the default customization for the 'value display' widget \
// (WidgetSet::ValueDisplay) in its medium size variant. Widgets using this configuration \
// display the value and unit aligned at the right widget edge.
$rect <750,679,1050,719>
$output false
autoobject WidgetSet::ValueDisplayConfig ValueDisplay
{
  preset ValueAlignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
  preset ValueFont = Resources::FontExtraLarge;
  preset UnitColorNegative = #00EB31FF;
  preset UnitColorPositive = #00FF47FF;
  preset FormatPlusSign = "";
  preset Layout = WidgetSet::ValueDisplayLayout.AlignValueLeftToUnit;
  preset WidgetMinSize = <60,45>;
}

$rect <750,560,950,600>
$output false
autoobject WidgetSet::PushButtonConfig IconButtonConfig
{
  preset IconTintActive = #FFFFFFFF;
  preset IconTintDefault = #FFFFFF80;
  preset FaceDefault = null;
  preset WidgetMaxSize = <30,30>;
  preset WidgetMinSize = <30,30>;
}

$rect <1079,640,1279,680>
$output false
resource Resources::Bitmap IconButton
{
  attr bitmapfile FileName = .\Resources\main.png;
  attr framesize FrameSize = <30,30>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <750,600,950,640>
$output false
autoobject WidgetSet::PushButtonConfig PushButtonConfig
{
  preset LabelColorActive = #00000080;
  preset LabelColorFocused = #FFFFFFFF;
  preset LabelColorDefault = #FFFFFFFF;
  preset LabelFont = Resources::DefaultFont;
  preset FaceTintActive = #FFFFFFFF;
  preset FaceTintFocused = #FFFFFFFF;
  preset FaceTintDisabled = #FFFFFF80;
  preset FaceTintDefault = #FFFFFFFF;
  preset FaceFrameActive = 1;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 0;
  preset FaceActive = FishTank::PushButton;
  preset FaceFocused = FishTank::PushButton;
  preset FaceDisabled = FishTank::PushButton;
  preset FaceDefault = FishTank::PushButton;
  preset WidgetMaxSize = <650,30>;
  preset WidgetMinSize = <65,30>;
}

$rect <1079,680,1279,720>
$output false
resource Resources::Bitmap PushButton
{
  attr bitmapfile FileName = .\PushButton.png;
  attr framesize FrameSize = <65,30>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1070,279,1270,319>
$output false
resource Resources::Bitmap Shadow2
{
  attr bitmapfile FileName = .\Resources\—Pngtree—border black shadow overlay_7586457.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <0,370,250,410>
$output false
autoobject Effects::SlideTransition SlideTransition
{
  preset Alignment = Effects::DialogAlignment[AlignHorzCenter, AlignVertCenter];
  preset Direction = Core::Direction.Right;
}

$rect <30,230,230,270>
$output false
class Background : Core::Group
{
  $rect <619,510,819,550>
  inherited property Bounds = <0,0,800,480>;

  $rect <840,490,1040,530>
  inherited method UpdateLayout()
  {
    /* first make the default layour arrangement */
    super( aSize );


  }

  $rect <840,530,1040,570>
  inherited method UpdateViewState()
  {
    super( aState );



    /* assign the bitmap according current selection  */
    if ( CurrentBackground == 1 )
      Background.Bitmap = FishTank::Bg1;
    else if ( CurrentBackground == 2 )
      Background.Bitmap = FishTank::Bg2;
    else
      Background.Bitmap = FishTank::Bg3;

         
      
  }

  // The property 'CurrentBackground' stores the momentary bitmap selection of the \
  // background component.
  $rect <880,19,1080,59>
  property int32 CurrentBackground = 1;

  $rect <890,59,1090,99>
  onset CurrentBackground
  {
    /* limit the given value to the allowed */
    if ( value < 0 )
      value = 0;
    if ( value > 2 )
      value = 2;

    /* check if the given value differs from the current value */
    if ( pure CurrentBackground == value )
      return;

    /* store the new value */
    pure CurrentBackground = value;

    notifyobservers ^CurrentBackground;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  // Method to shift the background image to the left
  $rect <850,400,1050,440>
  method void ShiftLeft()
  {
    /* make a parallaxe effect by shifting the background image to the left */
    ShiftEffect.Value1 = Rectangle.ScrollOffset;
    ShiftEffect.Value2 = point( Bounds.w - Rectangle.Bitmap.FrameSize.x, 0);
    postsignal ShiftEffect.StartEffect;

  }

  // Method to shift the background image to the right
  $rect <850,440,1050,480>
  method void ShiftRight()
  {
    /* make a parallaxe effect by shifting the background image to the right */
    ShiftEffect.Value1 = Rectangle.ScrollOffset;
    ShiftEffect.Value2 = <0,0>;
    postsignal ShiftEffect.StartEffect;

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,800,480>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,1,800,481>;
    preset Color = #FFD95DFF;
    preset Alignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
    preset Bitmap = null;
  }

  $rect <890,250,1090,290>
  inherited method Init()
  {
    attachobserver OnColorChange, ^FishTank::Device.Color;
    postsignal OnColorChange;

  }

  $rect <20,20,160,60>
  object Views::Rectangle ColorBG
  {
    preset Bounds = <-4,-1,802,479>;
    preset Color = #45E7FF88;
  }

  $rect <890,120,1090,160>
  property int32 Color;

  $rect <890,160,1090,200>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    notifyobservers ^Color;

    /* ...and finally, force an update */
    InvalidateViewState();
  }

  $rect <880,200,1080,240>
  onget Color
  {
    return pure Color;
  }

  $rect <890,290,1090,330>
  slot OnColorChange
  {
    ColorBG.Color=FishTank::Device.Color;
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateLayout
  $member UpdateViewState
  $member Rectangle
  $member Background
  $member CurrentBackground
  $member OnSetCurrentBackground
  $member ShiftLeft
  $member ShiftRight
  $member ColorBG
  $member Color
  $member OnSetColor
  $member OnGetColor
  $member OnColorChange
}

$rect <1070,359,1270,399>
$output false
resource Resources::Bitmap BackgroundPreview
{
  attr bitmapfile FileName = .\Resources\Fără titlu.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <60,35>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = RGB565;
  attr bitmapmode Mode = Default;
}

$rect <1280,320,1480,360>
$output false
resource Resources::Bitmap Bg2
{
  attr bitmapfile FileName = .\Resources\2.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = RGB565;
  attr bitmapmode Mode = Default;
}

$rect <1280,240,1480,280>
$output false
resource Resources::Bitmap Bg3
{
  attr bitmapfile FileName = .\Resources\wp4096562.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = RGB565;
  attr bitmapmode Mode = Default;
}

$rect <1280,279,1480,319>
$output false
resource Resources::Bitmap Bg1
{
  attr bitmapfile FileName = .\Resources\4adfe88fc4bafa09ca08490820f08d0f-600x300.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = RGB565;
  attr bitmapmode Mode = Default;
}

$rect <1070,400,1270,440>
$output false
resource Resources::Bitmap BackgroundFrame
{
  attr bitmapfile FileName = .\Resources\BackgroundFrame.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// This component implements an editor.
$rect <1040,70,1240,110>
$output false
class Editor : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,160,120>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point  rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32  newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
      ObtainFocus();

    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // The begin of the row reached? Skip to the end of the preceding row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // The end of the current row reached? Skip to the begin of the next
      // following row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <390,180,590,220>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <190,180,390,220>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <590,90,790,130>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32 inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <590,50,790,90>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <390,50,590,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <190,50,390,90>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,160,120>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,120>;
    preset Point3 = <160,120>;
    preset Point2 = <160,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <2,2,157,117>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <50,70>;
    preset Point1 = <50,50>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <590,140,790,180>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <390,140,590,180>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <190,140,390,180>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <590,10,790,50>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <390,10,590,50>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <190,10,390,50>
  property Resources::Font Font = Resources::FontMedium;
}

// This component implements a virtual keyboard.
$rect <1240,70,1440,110>
$output false
class VirtualKeyboard : Templates::AlphaNumKeyboard
{
  $rect <250,370,450,410>
  inherited property Bounds = <0,0,372,109>;

  $rect <480,250,680,290>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the affected keyboard.
    //
    // isKeyView --> the 'text' or 'image' view representing the pressed key.
    // isPressed --> the affected key should appear pressed.
    //
    var Core::View isKeyView = null;
    var bool       isPressed = ( TouchHandler.Down && TouchHandler.Inside ) || 
                                 FlashTimer.Enabled;

    // Search for the view representing the key at the recent touch position.
    // Do this however only when the position is valid - it lies inside the
    // area where keys are found (here the area of the TouchHandler) and the
    // key should appear pressed (isPressed == true)
    if ( isPressed && ( recentPosition == TouchHandler.GetExtent()))
      isKeyView = FindViewAtPosition( null, recentPosition, Core::ViewState[]);

    /*
       In this template, the keys are represented by simple 'text' and 'image'
       views. Any other view is considered as not corresponding to a key. Thus
       ignore every view, which is not an instance of 'text' or 'image'.
     
       TO DO:

       If you are using other views (not image nor text) to represent the keys,
       adapt the object runtime cast operations in the condition below to react
       on your particular views only. After this condition, 'isKeyView' should
       be either 'null' if the user is not pressing a key or it should refer to
       the view which represents the affected key.
    */

    if (((Views::Text)isKeyView == null ) && ((Views::Image)isKeyView == null ))
      isKeyView = null;

    /*

      TO DO:

      Depending on your keyboard design, you have surely added some new views
      to your keyboard. In the below code you should update the properties of
      these views. For example, when the user drags the finger between two keys
      one key should appear pressed while the other released.

      Whether the user has pressed/released a key can be estimated by comparing
      the variable 'isKeyView' with 'keyView'. If they differ, the user has
      pressed/released a key.

        if ( isKeyView != keyView )
          ...

      In practice, the variable 'isKeyView' represents the just pressed key.
      Your implementation should thus ensure, that the affected key appears
      pressed. If the user is not pressing any key, the variable is 'null'.

      The variable 'keyView' represents the key pressed in the preceding
      interaction. This key has thus to appear released. If there was no key
      pressed, the variable is 'null'.

      In the simplest case you modify the properties of the affected views, so
      they reflect their new state. Please note, the variables 'isKeyView' and
      'keyView' are declared with the generic Core::View class. In order to
      modify view specific properties you have to apply an object runtime cast
      operation on them. For example, if you are using 'text' views to represent
      keys, cast the variable to (Views::Text).

        if ( isKeyView != null )
          ((Views::Text)isKeyView).Color = color for a pressed key

        if ( keyView != null )
          ((Views::Text)keyView).Color = color for a released key

      Or you use, as demonstrated below, another views to highlight the area
      occupied by the affected key. For example, arrange some 'border' view
      to appear at the position of the pressed key with additional 5 pixel 
      padding:

        if ( isKeyView != null )
          BorderView.Bounds = isKeyView.GetExtent() * <5,5>;

      HINT:

      Instead of instantly alternate the views properties you can also start
      here effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the keyboard
      (e.g. 'isKeyView') with its preceding state (e.g. variable 'keyView').

      Assuming you have already added to your keyboard component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image lying behind the pressed key. Then following is 
      sufficient to trigger the animation:

        if (( isKeyView != null ) && ( keyView == null ))
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if (( isKeyView == null ) && ( keyView != null ))
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    // Detect a state alternation when the user presses a new or releases a
    // previously pressed key.
    if ( isKeyView != keyView )
    {
      var Views::Text  isTextKeyView  = (Views::Text)isKeyView;
      var Views::Text  textKeyView    = (Views::Text)keyView;
      var Views::Image isImageKeyView = (Views::Image)isKeyView;
      var Views::Image imageKeyView   = (Views::Image)keyView;

      // If the user is actually pressing a key, arrange the background view
      // just behind the affected key view so it appears selected. If no key
      // is pressed, the background should disappear.
      if ( isKeyView != null )
      {
        Highlight.Bounds  = isKeyView.GetExtent();
        Highlight.Visible = true;
      }
      else
        Highlight.Visible = false;

      // If the user has pressed a key represented by a 'text' view, change the
      // color of the text to appear highlighted.
      if ( isTextKeyView != null )
        isTextKeyView.Color = #FFFFFFFF;

      // If the user has released a key represented by a 'text' view, restore
      // the color of the text.
      if ( textKeyView != null )
        textKeyView.Color = #000000FF;

      // If the user has pressed a key represented by an 'image' view, change the
      // color of the bitmap to appear highlighted.
      if ( isImageKeyView != null )
        isImageKeyView.Color = #FFFFFFFF;

      // If the user has released a key represented by an 'image' view, restore
      // the color of the view.
      if ( imageKeyView != null )
        imageKeyView.Color = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    keyView = isKeyView;
  }

  $rect <710,290,910,330>
  inherited method Init()
  {
    // Just at the creation time of the virtual keyboard instance
    // load the default keyboard layout.
    loadLayoutFromString( layoutShiftOff );
  }

  // To do:
  // 
  // - Adjust the visible size of your keyboard (the thick blue border). This will \
  // be the keyboard's default size.
  // - Resize and arrange the member 'TouchHandler' so it covers the area where you \
  // intend to place the keys.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your keyboard.
  // - In this template, the individual keys are represented by text views 'TextKey01' \
  // .. 'TextKey47'.
  // - Special keys like the 'clear', 'enter' or 'shift' key are represented by image \
  // views 'ImageKeyClear', 'ImageKeyEnter', etc.
  // - The area for the 'space' key is displayed by a 'border' view 'AreaKeySpace'.
  // - Similarly, the 'shift' and 'caps-lock' keys have additional 'border' views \
  // 'ActiveKeyShiftLeft', 'ActiveCapsLock', which are displayed when the affected \
  // key has been activated.
  // - Remove the above described 'text', 'image' and 'border' views if you don't \
  // want them.
  // - Add more 'text', 'image', etc. views to represent more keys.
  // - Arrange the 'text' and 'image' views within the area of the 'TouchHandler'. \
  // The position of a view determines the area of the corresponding key.
  // - According to your desired keyboard design add and configure new decoration \
  // views (e.g. an image view to show some icon, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the keyboard's current state.
  // - Adapt the implementation of the 'activateKey' slot method. This method evaluates \
  // which key the user has pressed and feeds the corresponding key event to the \
  // application.
  // - The keyboard layout is determined by the strings in the variables 'layoutShiftOff' \
  // and 'layoutShiftOn'. Modify the strings accordingly to your desired layout. \
  // Every sign in the string corresponds to one key in the keyboard according the \
  // z-order in which the 'text' views 'TextKey01' .. 'TextKey47' are arranged.
  // - In the slot method 'activateKey' take a look at the code to switch the keyboard \
  // layout. In particular, when the user presses the 'shift' or 'caps-lock' keys \
  // the method switches the layout.
  // - You can also add and configure animation effects to your keyboard. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the keyboard itself is resized.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your keyboard. One property \
  // for every keyboard specific setting (e.g. 'Caption', 'Color', 'Font', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Font' should update the key related 'text' views in your \
  // component).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,430,990,1030>;
  }

  // Keyboard layout
  note group Note4
  {
    attr Bounds = <700,210,920,420>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <470,210,690,380>;
  }

  // Feedback flash effect
  note group Note2
  {
    attr Bounds = <240,210,460,340>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,210,230,420>;
  }

  // This string variable stores the keyboard layout for the case, there is a shift \
  // key pressed. Each character within this string does correspond to one key on \
  // the keyboard. By modifying this variable, the layout is changed.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,370,910,410>
  var string layoutShiftOn = "!\"§$$%&/()=?QWERTZUIOPÜ*ASDFGHJKLÖÄ\'>YXCVBNM;:_ ";

  // This string variable stores the keyboard layout for the case, there is no shift \
  // key pressed. Each character within this string does correspond to one key on \
  // the keyboard. By modifying this variable, the layout is changed.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,330,910,370>
  var string layoutShiftOff = "1234567890ßqwertzuiopü+asdfghjklöä#<yxcvbnm,.- ";

  // This variable refers to the view representing the actually pressed key or it \
  // is 'null' if the user is not touching a key.
  $rect <480,330,680,370>
  var Core::View keyView;

  // This variable stores the recent position inside the keyboard area where the \
  // user is touching the screen.
  $rect <20,370,220,410>
  var point recentPosition;

  // This timer object is used to flash the pressed key when the user has tapped \
  // it very quickly. This is just a visual feedback effect.
  $rect <250,250,450,290>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This method loads new keyboard layout. The layout is determined by the passed \
  // string parameter aLayoutString. The characters within the string correspond \
  // to the keys accordingly their order.
  // The order in which the characters are listed in the string corresponds to the \
  // z-order of the 'text' views 'TextKey01' .. 'TextKey47'.
  $rect <710,250,910,290>
  method void loadLayoutFromString( arg string aLayoutString )
  {
    var Core::View view  = TextKey01;
    var int32      keyNo = 0;

    // Traverse the entire list of views available within the keyboard component
    while ( view != null )
    {
      var Views::Text textKeyView = (Views::Text)view;

      // Is this a 'text' view representing a key?
      if ( textKeyView != null )
      {
        // From the layout string get the character corresponding to the key
        var string s = aLayoutString[ keyNo ];

        // Note, for text views, some characters have a special control function. 
        // To display those signs prefix them by a percent % sign
        if (( s == "%" ) || ( s == "^" ) || ( s == "~" ))
          s = '%' + s;

        // Let the 'text' view display the corresponding sign
        textKeyView.String = s;
        keyNo = keyNo + 1;
      }

      // Search for next view
      view = FindNextView( view, Core::ViewState[]);
    }
  }

  // This internal slot method is called when the recently pressed key should be \
  // activated. This is when the user presses on a key and then releases the finger \
  // again.
  $rect <480,290,680,330>
  slot activateKey
  {
    // Applying the object runtime casting test whether the user is
    // touching a key with 'text' caption.
    var Views::Text textKeyView = (Views::Text)keyView;

    // Depending on the pressed key, the following variables will be
    // initialized with the corresponding code.
    var char          charCode = '\0';
    var Core::KeyCode keyCode  = Core::KeyCode.NoKey;

    // Has the user touched (activated) one of the keys with text
    // as caption? Use the text as character code to feed the application 
    // with a keyboard event.
    if ( textKeyView != null )
      charCode = textKeyView.String[0];

    // Has the user touched the 'Tab' key?
    else if ( keyView == ImageKeyTab )
      keyCode = Core::KeyCode.Tab;

    // Has the user touched the 'Enter' key?
    else if ( keyView == ImageKeyEnter )
      keyCode = Core::KeyCode.Enter;

    // Has the user touched the 'Clear' key?
    else if ( keyView == ImageKeyClear )
      keyCode = Core::KeyCode.Backspace;

    // Has the user touched a 'Shift' key? This switches the layout for
    // the next sign
    else if (( keyView == ImageKeyShiftLeft ) || 
             ( keyView == ImageKeyShiftRight ))
    {
      // Toggle the highlight of the both 'Shift' keys. The 'CapsLock' key,
      // in turn, is de-highlighted.
      ActiveKeyShiftLeft.Visible  = !ActiveKeyShiftLeft.Visible;
      ActiveKeyShiftRight.Visible = ActiveKeyShiftLeft.Visible;
      ActiveKeyCapsLock.Visible   = false;

      // Depending on the actual 'Shift' key state -> load the right layout
      // version of the keyboard
      if ( ActiveKeyShiftLeft.Visible )
        loadLayoutFromString( layoutShiftOn );
      else
        loadLayoutFromString( layoutShiftOff );
    }

    // Has the user touched a 'CapsLock' key? This switches the layout
    // permanently
    else if ( keyView == ImageKeyCapsLock )
    {
      // Toggle the highlight of the 'CapsLock' key. The both 'Shift' keys,
      // in turn, are de-highlighted.
      ActiveKeyCapsLock.Visible   = !ActiveKeyCapsLock.Visible;
      ActiveKeyShiftLeft.Visible  = false;
      ActiveKeyShiftRight.Visible = false;

      // Depending on the actual 'Shift' key state -> load the right layout
      // version of the keyboard
      if ( ActiveKeyCapsLock.Visible )
        loadLayoutFromString( layoutShiftOn );
      else
        loadLayoutFromString( layoutShiftOff );
    }

    // Pressing a key while after the 'Shift' keys have been activated restores
    // the 'Shift' keys and switches back to the normal keyboard layout.
    if ((( charCode != '\0' ) || ( keyCode != Core::KeyCode.NoKey )) &&
           ActiveKeyShiftLeft.Visible )
    {
      ActiveKeyShiftLeft.Visible  = false;
      ActiveKeyShiftRight.Visible = false;
      loadLayoutFromString( layoutShiftOff );
    }

    // The user has pressed a regular character/digit key. Feed it as keyboard
    // event to the application.
    if ( charCode != '\0' )
    {
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, true );
      GetRoot().DriveKeyboardHitting( Core::KeyCode.NoKey, charCode, false );
    }

    // The user has pressed a special key (e.g. Enter). Feed it as keyboard
    // event to the application.
    if ( keyCode != Core::KeyCode.NoKey )
    {
      GetRoot().DriveKeyboardHitting( keyCode, '\0', true );
      GetRoot().DriveKeyboardHitting( keyCode, '\0', false );
    }
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <250,290,450,330>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the keyboard to update 
    // its appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the key is activated.
    signal activateKey;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the keyboard. This updates the keyboard to highlight the key at the new touch \
  // position.
  $rect <20,330,220,370>
  slot onDragTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Remember the new position where the user recently touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the keyboard area. This activates the key the user has touched.
  $rect <20,290,220,330>
  slot onReleaseTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // Did the user moved the finger outside the keyboard's area? In such case
    // the keyboard is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user has pressed and held a key for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The keyboard can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      signal activateKey;

    // The user has tapped the keyboard very quickly. Defer the key activation
    // to give the user first a short visual feedback that the key has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the keyboard area.
  $rect <20,250,220,290>
  slot onPressTouch
  {
    // Every time the user touches the keyboard or drags the finger inside/outside
    // a key area request the keyboard update its appearance. The update will occur
    // in the UpdateViewState() method.
    InvalidateViewState();

    // The keyboard is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the keyboard in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new key interaction.
    if ( FlashTimer.Enabled )
    {
      signal activateKey;
      FlashTimer.Enabled = false;
    }

    // Remember the new position where the user has touched the screen
    recentPosition = TouchHandler.CurrentPos;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,370,110>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,370,110>;
    preset Width = 3;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <8,103>;
    preset Point3 = <362,103>;
    preset Point2 = <362,7>;
    preset Point1 = <8,7>;
    preset OnDrag = onDragTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset EnableMultiTouch = true;
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Border AreaKeySpace
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <126,84,244,103>;
    preset Width = 2;
    preset Color = #A5A3A2FF;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyShiftRight
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <315,65,362,84>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyShiftLeft
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <8,65,55,84>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Border ActiveKeyCapsLock
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <8,45,46,65>;
    preset Width = 3;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Highlight
  {
    preset Bounds = <126,84,244,103>;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey01
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <31,7,55,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey02
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <55,7,79,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey03
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <79,7,102,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey04
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <102,7,126,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey05
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <126,7,149,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey06
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <149,7,172,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey07
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <172,7,198,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey08
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <198,7,221,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey09
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <221,7,244,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey10
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <244,7,268,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey11
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <268,7,291,26>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey12
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <39,26,64,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey13
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <64,26,87,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey14
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <87,26,110,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey15
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <110,26,134,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey16
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <134,26,158,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey17
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <158,26,180,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey18
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <180,26,205,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey19
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <205,26,229,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey20
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <229,26,252,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey21
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <252,26,275,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey22
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <275,26,299,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey23
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <299,26,324,45>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey24
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <46,45,71,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey25
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <71,45,95,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey26
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <95,45,118,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey27
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <118,45,141,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey28
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <141,45,165,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey29
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <165,45,190,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey30
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <190,45,212,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey31
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <212,45,236,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey32
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <236,45,260,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey33
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <260,45,283,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey34
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <283,45,306,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey35
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <306,45,331,65>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey36
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <55,65,79,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey37
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <79,65,102,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey38
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <102,65,126,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey39
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <126,65,149,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey40
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <149,65,172,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey41
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <172,65,198,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey42
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <198,65,221,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey43
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <221,65,244,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey44
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <244,65,268,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey45
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <268,65,291,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey46
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <291,65,315,84>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text TextKey47
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <126,84,244,103>;
    preset String = "X";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyTab
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <8,26,39,45>;
    preset Color = #000000FF;
    preset FrameNumber = 5;
    preset Bitmap = Resources::KeyIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyCapsLock
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <8,45,46,65>;
    preset Color = #000000FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::KeyIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyShiftLeft
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <8,65,55,84>;
    preset Color = #000000FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::KeyIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyClear
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <291,7,331,26>;
    preset Color = #000000FF;
    preset FrameNumber = 4;
    preset Bitmap = Resources::KeyIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyEnter
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <331,26,362,65>;
    preset Color = #000000FF;
    preset FrameNumber = 6;
    preset Bitmap = Resources::KeyIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image ImageKeyShiftRight
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <315,65,362,84>;
    preset Color = #000000FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::KeyIconsSmall;
  }

  // Handling the Close button
  note group Note6
  {
    attr Bounds = <490,10,920,160>;
  }

  $rect <710,100,910,140>
  slot onCloseRelease
  {
    // The user has pressed and released the close button in the upper-right
    // corner
    if ( CloseTouchHandler.Inside )
      signal OnHide;

    // Update the appearance of the Close button
    BackClose.Color  = #FF000D5A;
    ImageClose.Color = #000000FF;

  }

  $rect <710,60,910,100>
  slot onCloseEnterLeave
  {
    // Update the appearance of the Close button
    if ( CloseTouchHandler.Inside )
    {
      BackClose.Color  = #FF0000FF;
      ImageClose.Color = #FFFFFFFF;
    }
    else
    {
      BackClose.Color  = #FF000D5A;
      ImageClose.Color = #000000FF;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle BackClose
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <339,7,362,26>;
    preset Color = #FF000D5A;
  }

  $rect <20,20,160,60>
  object Views::Image ImageClose
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <339,7,362,26>;
    preset Color = #000000FF;
    preset FrameNumber = 12;
    preset Bitmap = Resources::KeyIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler CloseTouchHandler
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Point4 = <339,7>;
    preset Point3 = <362,7>;
    preset Point2 = <362,26>;
    preset Point1 = <339,26>;
    preset OnLeave = onCloseEnterLeave;
    preset OnEnter = onCloseEnterLeave;
    preset OnRelease = onCloseRelease;
  }

  // The property 'OnHide' can refer to a slot method which is called when the user \
  // has dragged the keyboard outside the screen.
  $rect <500,60,700,100>
  property slot OnHide = null;

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member Init
  $member Bounds
  $member UpdateViewState
  $member Note5
  $member Note4
  $member Note3
  $member Note2
  $member Note1
  $member layoutShiftOn
  $member layoutShiftOff
  $member keyView
  $member recentPosition
  $member FlashTimer
  $member loadLayoutFromString
  $member activateKey
  $member onFlashTimer
  $member onDragTouch
  $member onReleaseTouch
  $member onPressTouch
  $member Background
  $member Border
  $member TouchHandler
  $member AreaKeySpace
  $member ActiveKeyShiftRight
  $member ActiveKeyShiftLeft
  $member ActiveKeyCapsLock
  $member Highlight
  $member TextKey01
  $member TextKey02
  $member TextKey03
  $member TextKey04
  $member TextKey05
  $member TextKey06
  $member TextKey07
  $member TextKey08
  $member TextKey09
  $member TextKey10
  $member TextKey11
  $member TextKey12
  $member TextKey13
  $member TextKey14
  $member TextKey15
  $member TextKey16
  $member TextKey17
  $member TextKey18
  $member TextKey19
  $member TextKey20
  $member TextKey21
  $member TextKey22
  $member TextKey23
  $member TextKey24
  $member TextKey25
  $member TextKey26
  $member TextKey27
  $member TextKey28
  $member TextKey29
  $member TextKey30
  $member TextKey31
  $member TextKey32
  $member TextKey33
  $member TextKey34
  $member TextKey35
  $member TextKey36
  $member TextKey37
  $member TextKey38
  $member TextKey39
  $member TextKey40
  $member TextKey41
  $member TextKey42
  $member TextKey43
  $member TextKey44
  $member TextKey45
  $member TextKey46
  $member TextKey47
  $member ImageKeyTab
  $member ImageKeyCapsLock
  $member ImageKeyShiftLeft
  $member ImageKeyClear
  $member ImageKeyEnter
  $member ImageKeyShiftRight
  $member Note6
  $member onCloseRelease
  $member onCloseEnterLeave
  $member BackClose
  $member ImageClose
  $member CloseTouchHandler
  $member OnHide
}

$rect <1070,240,1270,280>
$output false
resource Resources::Bitmap Shadow
{
  attr bitmapfile FileName = .\Resources\frame.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1070,200,1270,240>
$output false
resource Resources::Bitmap PanelBackground4
{
  attr bitmapfile FileName = .\Resources\rounded-rectangle-256.png;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This component implements a simple menu item containing a kind of embedded horizontal \
// slider. The user can change the value of the item accordingly.
$rect <720,250,920,290>
$output false
class SliderItem : Templates::SliderItem
{
  $rect <480,410,680,450>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,250,1140,290>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       minimum width for the item.

    */

    // We assume: the item requires space for the caption and 20 pixel margin on
    // the left and on the right of the caption plus the space needed for the slider.
    // Important: perform the calculation without the caption text being evtl.
    // truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 20 + Track.Bounds.w, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,250,910,290>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isDragging --> the user is currently touching the item's slider knob.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isDragging = TouchHandler.Down || KeyPlusHandler.Down ||
                          KeyMinusHandler.Down;

    /*

      TO DO 1:

      The code below calculates from the items's current value the knob
      position. You will need to adapt in this code three aspects:

      - The initialization for 'minPos' variable. It determines the left-
        most possible position for the knob. It is expressed in pixel.

      - The initialization for 'maxPos' variable. It determines the right-
        most position for the knob. It is expressed in pixel. Please note
        that you need to subtract the width of the knob itself here.

      - The body of the 'if ( newKnobPos != oldKnobPos ) ...' condition.
        Depending on your design you have surely added new views to your
        item. Some of these views are intended to represent the slider's
        knob. You will need to move these views as demonstrated below:

          if ( newKnobPos != oldKnobPos )
          {
            TouchHandler. MoveView( newKnobPos - oldKnobPos, false );
            YourKnobView1.MoveView( newKnobPos - oldKnobPos, false );
            YourKnobView2.MoveView( newKnobPos - oldKnobPos, false );
            ...
          }

      HINT 1:

      When you change the initialization for 'minPos' ... 'maxPos', you
      should also adapt the same in the slot method 'onDragTouch'.

    */

    // Get the current pixel position of the slider's knob (corresponds
    // to the touch handler area) and the min/max positions the user may
    // drag the knob within the slider's bounds.
    var rect  knobArea   = Knob.GetExtent();
    var int32 minPos     = Track.Bounds.x1;
    var int32 maxPos     = Track.Bounds.x2 - knobArea.w;
    var point oldKnobPos = knobArea.origin;
    var point newKnobPos = oldKnobPos;

    // Convert the slider's current value to a pixel position within the
    // range allowed for the knob to be moved.
    if ( MaxValue != MinValue )
      newKnobPos.x = ((( CurrentValue - MinValue ) * ( maxPos - minPos )) /
                       ( MaxValue - MinValue )) + minPos;

    // If the just calculated new knob position does differ from the knob's
    // current position, move the knob (and the associated touch handler)
    // accordingly.
    if ( newKnobPos != oldKnobPos )
    {
      TouchHandler.MoveView( newKnobPos - oldKnobPos, false );
      Knob.        MoveView( newKnobPos - oldKnobPos, false );
    }

    /*

      TO DO 2:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two different images
      to show the knob (one used for an inactive slider and one for a slider
      the user is dragging the knob actively), following can be done:

        knobImageDragging.Visible =  isDragging;
        knobImageInactive.Visible = !isDragging;


      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isDragging') with its preceding state (e.g. variable 'dragging').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isDragging && !dragging )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isDragging && dragging )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      
      Knob.Color        = #b3cd55ff;

    }

    else if ( isDragging )
    {
      
      Knob.Color        = #b3cd55ff;
    }

    else if ( isSelected )
    {
      
      Knob.Color        =#b3cd55ff;
    }

    // Enabled but not pressed nor selected.
    else
    {
      
      Knob.Color        = #b3cd55ff;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // dragging <<-->> not dragging transition.
    enabled  = isEnabled;
    selected = isSelected;
    dragging = isDragging;
  }

  // Controller events
  note group Note7
  {
    attr Bounds = <470,210,690,300>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,210,1150,300>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,210,920,420>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,210,460,460>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,210,230,420>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,370,910,410>
  var bool dragging;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,330,910,370>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,290,910,330>
  var bool enabled;

  // This internal variable stores the item's value at the moment when the user pressed \
  // a key handled by the @KeyPlusHandler or @KeyMinusHandler. It is used to detect \
  // the modification of the slider's value when the user releases the key.
  $rect <250,410,450,450>
  var int32 keyStartValue;

  // This internal variable stores the item's value at the moment when the user begun \
  // to drag the knob. It is used to calculate the new value from the knob displacement.
  $rect <20,370,220,410>
  var int32 touchStartValue;

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of this key handler, the handler is activated and the \
  // method '@onPressKey' is called. When the user releases the key again, the method \
  // '@onReleaseKey' is called.
  $rect <250,290,450,330>
  object Core::KeyPressHandler KeyMinusHandler
  {
    preset OnRelease = onReleaseKey;
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Minus;
    preset OnHold = onPressKey;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of this key handler, the handler is activated and the \
  // method '@onPressKey' is called. When the user releases the key again, the method \
  // '@onReleaseKey' is called.
  $rect <250,250,450,290>
  object Core::KeyPressHandler KeyPlusHandler
  {
    preset OnRelease = onReleaseKey;
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Plus;
    preset OnHold = onPressKey;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the item will update itself.
  $rect <480,250,680,290>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the item.
    if ( Outlet != null )
      CurrentValue = Outlet^;
  }

  // This internal slot method is called when either '@KeyPlusHandler' or '@KeyMinusHandler' \
  // receives a key up event. With this the alternation of the item's value with \
  // keys ends. The method has the job to notify the owner that the user has finished \
  // the interaction.
  $rect <250,370,450,410>
  slot onReleaseKey
  {
    // To avoid interferences when the user tries to interact with the item
    // simultaneously via keyboard and touch screen, the touch handler is disabled
    // while the keyboard interaction is in progress. When the keyboard interaction
    // ends, enable the touch handler again.
    TouchHandler.Enabled  = true;

    // Releasing a key may affect the appearance of the item to change. Request
    // the UpdateViewState() method to be called in order to refresh the item's
    // appearance.
    InvalidateViewState();

    // Did the user really changed the item's value? If yes, notify the owner.
    if ( CurrentValue != keyStartValue )
    {
      postsignal OnApply;

      // If a property is associated to the item, update it accordingly and notify
      // other widgets also associated to this property.
      if ( Outlet != null )
      {
        Outlet^ = CurrentValue;
        notifyobservers Outlet; 
      }
    }
  }

  // This internal slot method is called when either '@KeyPlusHandler' or '@KeyMinusHandler' \
  // has been activated. The method increments or decrements the item's current value.
  $rect <250,330,450,370>
  slot onPressKey
  {
    // To avoid interferences when the user tries to interact with the item
    // simultaneously via keyboard and touch screen, disable the touch handler
    // while the keyboard interaction is in progress.
    TouchHandler.Enabled  = false;

    // Pressing a key may affect the appearance of the item to change. Request
    // the UpdateViewState() method to be called in order to refresh the item's
    // appearance.
    InvalidateViewState();

    var int32 oldValue = CurrentValue;

    // With the first key press event, remember which was the item's value at
    // the beginning of the interaction. Later when the user releases the key,
    // this remembered value is compared with the current value to decide whether
    // notify or not the owner about an alternation of the value.
    if ( !((Core::KeyPressHandler)sender).Repetition )
      keyStartValue = CurrentValue;

    // Depending on which key handler has fired, increment or decrement the
    // item's current value.
    if ( sender == KeyPlusHandler  ) CurrentValue = oldValue + 1;
    if ( sender == KeyMinusHandler ) CurrentValue = oldValue - 1;

    // The knob has already reached the min/max position.
    if ( oldValue == CurrentValue )
      return;

    // Notify the owner of the slider that the value has been changed.
    postsignal OnChange;

    // If a property is associated to the item, update it accordingly and notify
    // other widgets also associated to this property.
    if ( Outlet != null )
    {
      Outlet^ = CurrentValue;
      notifyobservers Outlet; 
    }
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item's knob. The method calculates from the made displacement the alternation \
  // of the item's value and updates the item accordingly.
  $rect <20,330,220,370>
  slot onDragTouch
  {
    /*

      TO DO:

      The code below calculates from the user touch interaction the new
      item's value. You will need to adapt in this code two aspects:

      - The initialization for 'minPos' variable. It determines the left
        most possible position for the knob. It is expressed in pixel.

      - The initialization for 'maxPos' variable. It determines the right
        most position for the knob. It is expressed in pixel. Please note
        that you need to subtract the width of the knob itself here.

      HINT:

      When you change the initialization for 'minPos' ... 'maxPos', you
      should also adapt the same in the method 'UpdateViewState()'.

    */

    // Calculate the displacement in pixel relative to the originally touched position.
    // Also calculate the possible movement area for the knob --> the range between
    // 'minPos' and 'maxPos'.
    var point delta    = TouchHandler.CurrentPos - TouchHandler.HittingPos;
    var int32 minPos   = Track.Bounds.x1;
    var int32 maxPos   = Track.Bounds.x2 - Knob.GetExtent().w;
    var int32 oldValue = CurrentValue;

    // Calculate from the knob displacement the alternation of the item's value.
    // Knowing the value at the beginning of the drag interaction -> get the new
    // item's value.
    if ( maxPos > minPos )
      CurrentValue = (( delta.x * ( MaxValue - MinValue )) / ( maxPos - minPos )) +
                        touchStartValue;

    // The displacement was too small to change the item's value or the knob has
    // already reached the min/max position.
    if ( oldValue == CurrentValue )
      return;

    // Notify the owner of the item that the value has been changed.
    postsignal OnChange;

    // If a property is associated to the item, update it accordingly and notify
    // other widgets also associated to this property.
    if ( Outlet != null )
    {
      Outlet^ = CurrentValue;
      notifyobservers Outlet; 
    }
  }

  // This internal slot method is called when the user releases the screen after \
  // touching and evtl. dragging the item's knob --> when the drag interaction ends.
  $rect <20,290,220,330>
  slot onReleaseTouch
  {
    // To avoid interferences when the user tries to interact with the item
    // simultaneously via keyboard and touch screen, the key handler are disabled
    // while the touch interaction is in progress. When the touch interaction
    // ends, enable the key handlers again.
    KeyPlusHandler.Enabled  = true;
    KeyMinusHandler.Enabled = true;

    // When the touch interaction ends, the appearance of the item may change.
    // Request the UpdateViewState() method to be called in order to refresh the
    // item's appearance.
    InvalidateViewState();

    // Did the user really changed the item's value? If yes, notify the owner.
    if ( CurrentValue != touchStartValue )
      postsignal OnApply;
  }

  // This internal slot method is called when the user touches within the item's \
  // knob area --> when the drag interaction begins.
  $rect <20,250,220,290>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

    // To avoid interferences when the user tries to interact with the item
    // simultaneously via keyboard and touch screen, disable the key handler
    // while the touch interaction is in progress.
    KeyPlusHandler.Enabled  = false;
    KeyMinusHandler.Enabled = false;

    // Touching the item may affect its appearance to change. Request the
    // UpdateViewState() method to be called in order to refresh the items's
    // appearance.
    InvalidateViewState();

    // Remember which was the item's value at the beginning of the knob drag
    // operation. It is used in the slot method 'onDragTouch' to calculate the
    // value from the movement the user made on the screen.
    touchStartValue = CurrentValue;
  }

  $rect <650,140,850,180>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <850,50,1050,90>
  onset MaxValue
  {
    // Check if the given value differs from the current value
    if ( pure MaxValue == value )
      return;

    // Store the new value ...
    pure MaxValue = value;

    // ... and finally, force an update
    InvalidateViewState();
  }

  $rect <650,50,850,90>
  onset MinValue
  {
    // Check if the given value differs from the current value
    if ( pure MinValue == value )
      return;

    // Store the new value ...
    pure MinValue = value;

    // ... and finally, force an update
    InvalidateViewState();
  }

  $rect <450,90,650,130>
  onget CurrentValue
  {
    // Get the internally stored value of the property 'CurrentValue'.
    var int32 value = pure CurrentValue;

    // When reading the property 'CurrentValue' limit the result to the
    // range specified by the properties 'MinValue' and 'MaxValue'.
    // Note, the range can be 'inverted'.
    if ( MinValue > MaxValue )
    {
      if ( value < MaxValue ) value = MaxValue;
      if ( value > MinValue ) value = MinValue;
    }
    else
    {
      if ( value < MinValue ) value = MinValue;
      if ( value > MaxValue ) value = MaxValue;
    }

    return value;
  }

  $rect <450,50,650,90>
  onset CurrentValue
  {
    // Check if the given value differs from the current value.
    if ( pure CurrentValue == value )
      return;

    // Store the new value ...
    pure CurrentValue = value;

    // ... and finally, force an update.
    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::Rectangle Track
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <3,20,213,24>;
    preset ColorBL = #FfFfFFFF;
    preset ColorBR = #FfFfFFFF;
    preset ColorTR = #FfFfFFFF;
    preset ColorTL = #FfFfFFFF;
    preset Color = #FfFfFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Point4 = <170,29>;
    preset Point3 = <189,29>;
    preset Point2 = <189,10>;
    preset Point1 = <170,10>;
    preset OnDrag = onDragTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Knob
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <170,10,190,30>;
    preset Color = #FFffffff;
  }

  // The property 'OnApply' can refer to a slot method, which will receive a signal \
  // when the user has released the item after dragging its knob. Thereupon the method's \
  // logic will be executed. In the associated slot method you can evaluate the item's \
  // current value @CurrentValue.
  $rect <850,140,1050,180>
  property slot OnApply = null;

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user drags the item's knob. Thereupon the method's logic will \
  // be executed. In the associated slot method you can evaluate the item's current \
  // value @CurrentValue.
  $rect <850,100,1050,140>
  property slot OnChange = null;

  // The property 'Outlet' can refer to any other 'int32' property the item should \
  // remain synchronized with. When the user drags the slider's knob, the affected \
  // property is automatically updated to reflect the slider's current value. On \
  // the other hand, when the referred property is modified by another one, the item \
  // is automatically notified to remain in sync with the property.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the item represents the 'View' and 'Controller' and the property referred \
  // via 'Outlet' can be seen as a part of the 'Model'.
  $rect <650,100,850,140>
  property ^int32 Outlet = null;

  // The property 'MaxValue' defines the slider item's possible value at the right \
  // end of the slider's movement range.
  $rect <850,10,1050,50>
  property int32 MaxValue = 100;

  // The property 'MinValue' defines the slider item's possible value at the left \
  // end of the slider's movement range.
  $rect <650,10,850,50>
  property int32 MinValue = 0;

  // The property 'CurrentValue' stores the momentary value of the slider item. The \
  // value is limited automatically to the range between @MinValue and @MaxValue.
  $rect <450,10,650,50>
  property int32 CurrentValue = 50;
}

// This component implements a simple menu item. When activating the item a sub menu \
// is shown providing the user options to select. This item also displays the actually \
// selected option.
$rect <720,330,920,370>
$output false
class OptionItem1 : Templates::OptionItem
{
  $rect <20,340,220,380>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       minimum width for the item.

    */

    // We assume: the item requires space for 2 x caption and 10 pixel margin on
    // its side. Important: perform the calculation without the caption text being
    // evtl. truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point(( CaptionText.GetContentArea().w + 10 ) * 2, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color  = #AAAAAAFF;
      Border.Visible    = false;
      CaptionText.Color = #888888FF;
      PreviewText.Color = #888888FF;
      ArrowImage.Color  = #888888FF;
    }

    else if ( isPressed )
    {
      Background.Color  = #FF0000FF;
      Border.Color      = #000000FF;
      Border.Visible    = true;
      CaptionText.Color = #FFFFFFFF;
      PreviewText.Color = #FFFFFFFF;
      ArrowImage.Color  = #FFFFFFFF;
    }

    else if ( isSelected )
    {
      Background.Color  = #FFFFFFFF;
      Border.Color      = #444444FF;
      Border.Visible    = true;
      CaptionText.Color = #000000FF;
      PreviewText.Color = #000000FF;
      ArrowImage.Color  = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color  = #FFFFFFFF;
      Border.Visible    = false;
      CaptionText.Color = #000000FF;
      PreviewText.Color = #000000FF;
      ArrowImage.Color  = #000000FF;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
  }

  // Controller events
  note group Note9
  {
    attr Bounds = <470,290,690,380>;
  }

  // Controller events
  note group Note8
  {
    attr Bounds = <240,290,460,380>;
  }

  // Activation
  note group Note7
  {
    attr Bounds = <930,250,1150,340>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // To do:
  // 
  // - Adjust the visible size of your item (the thick blue border). This will be \
  // the item's default size.
  // - Resize the member 'TouchHandler' so it still fills the items's new area.
  // - Remove the 'Background', 'Border' and 'ArrowImage' members if you want other \
  // views to be shown instead these in your item.
  // - If you don't want the caption text to be shown, remove also the members 'CaptionText' \
  // and the property 'Caption' together with its 'OnSetCaption' method.
  // - According to your desired item design add and configure new views (e.g. an \
  // image view to show an icon in the item, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the item's current state.
  // - You can also add and configure animation effects to your item. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your item.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the item itself is resized.
  // - Adapt the method GetMinimalSize(). The method should calculate the minimal \
  // width the item will occupy within the menu.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // item to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your item. One property \
  // for every item specific setting (e.g. 'Icon', 'Color', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your item where \
  // the icon is shown).
  // - Adapt the method 'openSubMenu' and specify the animations to perform when \
  // presenting the sub-menu.
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,400,990,830>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,360>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the the item has been activated. Thereupon \
  // the sub menu is opened and presented.
  $rect <940,290,1140,330>
  slot openSubMenu
  {
    /*

      The following code creates a new instance of the menu GUI component specified in the property
      'SubMenuClass' and presents the component as dialog.

      HINT :

      Depending on your design requirements you can modify the PresentDialog() invocation in order
      to determine the animations to show/hide the menu. Actually, the following implementation
      hides the superior menu when entering the sub-menu. If you don't want it, remove the expression
      'Effects::ShowHideCentered' and replace it by 'null'. In this manner the superior will remain
      visible while the sub-menu is active.

    */
    if ( Owner && Owner.IsCurrentDialog() && SubMenuClass )
      GetRoot().PresentDialog((Core::Group)new SubMenuClass, null, null, null, null, Effects::ShowHideCentered, null, null, null, false );
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <480,330,680,370>
  slot onUpdatePreview
  {
    var string previewString;

    // The preview string is determined by the Radio Menu Item selected actually
    // in the sub menu.
    if ( SubMenuClass )
    {
      // Instantiate temporarily the sub menu and ...
      var Core::Group subMenu = (Core::Group)new SubMenuClass;
      var Core::View  view;
      
      // ... evaluate all views existing in the sub menu searching for a Radio Item
      // matching the actual selection.
      while ( !!(view = subMenu.FindNextView( view, Core::ViewState[ Embedded ])))
      {
        var FishTank::RadioItem radioItem = (FishTank::RadioItem)view;

        // Found a selected radio item? Then query its caption.
        if ( radioItem && (( radioItem.OutletSelector == Selection ) || radioItem.Selected ))
        {
          previewString = radioItem.Caption;
          break;
        }
      }
    }

    // Update the preview text to the caption of the found Radio Item.
    PreviewText.String = previewString;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <250,330,450,370>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the item.
    if ( Outlet != null )
      Selection = Outlet^;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal openSubMenu;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal openSubMenu;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal openSubMenu;
      FlashTimer.Enabled = false;
    }
  }

  $rect <850,50,1050,90>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <650,50,850,90>
  onset Selection
  {
    // Check if the given value differs from the current value
    if ( pure Selection == value )
      return;

    // Store the new state ...
    pure Selection = value;

    // When changing the selection, trigger an update of the preview text
    postsignal onUpdatePreview;
  }

  $rect <450,50,650,90>
  onset SubMenuClass
  {
    // Verify, whether the assigned class descends from Core::Group
    if ( value && !(Core::Group)value )
      throw "The specified SubMenuClass does not descend from Core::Group.";

    // Check if the given value differs from the current value
    if ( pure SubMenuClass == value )
      return;

    // Store the new state ...
    pure SubMenuClass = value;

    // When changing the sub menu class, trigger an update of the preview text.
    // Possibly, the new sub menu contains different strings for the options.
    postsignal onUpdatePreview;
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,220,40>;
    preset Width = 3;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,39>;
    preset Point3 = <219,39>;
    preset Point2 = <219,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,110,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text PreviewText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <110,0,193,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Option";
    preset Font = Resources::FontSmall;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Image ArrowImage
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <193,0,220,40>;
    preset Color = #000000FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  // The property 'Outlet' can refer to any other 'int32' property the item should \
  // remain synchronized with. When the user selects the item, the affected property \
  // is automatically updated to the value found in the property @OutletSelector. \
  // On the other hand, when the referred property is modified by another one, the \
  // item is automatically notified to remain in sync with the property. The item \
  // appears selected, when the referred property has the value equal to @OutletSelector.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the item represents the 'View' and 'Controller' and the property referred \
  // via 'Outlet' can be seen as a part of the 'Model'.
  $rect <850,10,1050,50>
  property ^int32 Outlet = null;

  // The property 'Selection' stores a value representing the current selection.
  $rect <650,10,850,50>
  property int32 Selection = 0;

  // The property 'SubMenuClass' determines the menu GUI component to create and \
  // present when the user activates the menu item. This menu should consist of Radio \
  // Menu Items.
  $rect <450,10,650,50>
  property class SubMenuClass = null;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

// This component implements a simple menu item containing a kind of embedded radio \
// button. The user can select the item within a group of items existing in the same \
// menu.
$rect <720,290,920,330>
$output false
class RadioItem : Templates::RadioItem
{
  $rect <480,360,680,400>
  inherited property Bounds = <0,0,119,53>;

  $rect <940,240,1140,280>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       miniumum width for the item.

    */

    // We assume: the item requires space for the caption, 60 pixel margin on
    // its left side and some space for the check image on the right.
    // Important: perform the calculation without the caption text being evtl.
    // truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 60 + CheckImage.Bounds.w, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,240,910,280>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    // isChecked  --> the item is in its 'ON' state.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;
    var bool isChecked  = Selected;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
     Border.Color=#ffffffff;

    }

    else if ( isPressed )
    {
           Border.Color=#ffffffff;
    }

    else if ( isSelected )
    {
               Border.Color=#ffffffff;
    }

    // Enabled but not pressed nor selected.
    else
    {
                    Border.Color=#00000000;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
    checked  = isChecked;
  }

  // Controller events
  note group Note8
  {
    attr Bounds = <240,340,460,430>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,200,1150,290>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,200,920,450>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,200,690,330>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,200,460,330>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,200,230,370>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,400,910,440>
  var bool checked;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,360,910,400>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,320,910,360>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,280,910,320>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,240,680,280>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,240,450,280>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <250,380,450,420>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the radio item.
    if ( Outlet != null )
      Selected = Outlet^ == OutletSelector;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,280,680,320>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    // Select the item and notify the owner of the item.
    if ( !Selected )
    {
      Selected = true;
      postsignal OnSelect;

      // If a property is associated to the item, update it accordingly and notify
      // other widgets also associated to this property.
      if ( Outlet != null )
      {
        Outlet^ = OutletSelector;
        notifyobservers Outlet; 
      }
    }

  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,280,450,320>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      // Select the item and notify the owner of the item.
      if ( !Selected )
      {
        Selected = true;
        postsignal OnSelect;

        // If a property is associated to the item, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,320,220,360>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,280,220,320>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
    {
      // Select the item and notify the owner of the item.
      if ( !Selected )
      {
        Selected = true;
        postsignal OnSelect;

        // If a property is associated to the item, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,240,220,280>
  slot onPressTouch
  {
    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      // Select the item and notify the owner of the item.
      if ( !Selected )
      {
        Selected = true;
        postsignal OnSelect;

        // If a property is associated to the item, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
      FlashTimer.Enabled = false;
    }
  }

  $rect <650,140,850,180>
  onset OutletSelector
  {
    // Check if the given value differs from the current value
    if ( pure OutletSelector == value )
      return;

    pure OutletSelector = value;

    // Update the current state of the widget
    if ( Outlet != null )
      Selected = ( Outlet^ == OutletSelector );
  }

  $rect <450,140,650,180>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <250,140,450,180>
  onset Selected
  {
    // Check if the given value differs from the current value
    if ( pure Selected == value )
      return;

    // Store the new state ...
    pure Selected = value;

    // ... and finally, request an update
    InvalidateViewState();
  }

  $rect <450,50,650,90>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the icon in the menu
    Image.Bitmap = value;
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <1,40>;
    preset Point3 = <117,40>;
    preset Point2 = <117,1>;
    preset Point1 = <1,1>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <10,0,50,40>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // as soon as the user has selected the radio item. Thereupon the method's logic \
  // will be executed.
  $rect <850,100,1050,140>
  property slot OnSelect = null;

  // The property 'OutletSelector' contains a value identifying the radio item within \
  // a group of radio items. At the runtime, the item compares this value with the \
  // value of the property referred by @Outlet and if both are equal, the radio item \
  // assumes the 'selected' state (its property @Selected is 'true'). If the values \
  // are different, the radio item appears not selected. This selector is useful \
  // to build a group of radio item that refers to the same outlet. Different selectors \
  // for each radio item manages automatically the group of radio items.
  $rect <650,100,850,140>
  property int32 OutletSelector = 0;

  // The property 'Outlet' can refer to any other 'int32' property the item should \
  // remain synchronized with. When the user selects the radio item, the affected \
  // property is automatically updated to the value found in the property @OutletSelector. \
  // On the other hand, when the referred property is modified by another one, the \
  // radio item is automatically notified to remain in sync with the property. The \
  // item appears selected, when the referred property has the value equal to @OutletSelector.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the radio item represents the 'View' and the property referred via 'Outlet' \
  // can be seen as a part of the 'Model'.
  $rect <450,100,650,140>
  property ^int32 Outlet = null;

  // The property 'Selected' stores the current state of the radio item. As long \
  // as the property is 'false', the item should appear in the not-selected state. \
  // As long as the property is 'true', the item should appear in selected state.
  $rect <250,100,450,140>
  property bool Selected = false;

  // The property 'Icon' can refer to a bitmap to show in the menu's caption area.
  $rect <450,10,650,50>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <10,0,50,28>;
    preset Color = #22BBFFFF;
  }
}

// This component implements a simple menu item containing a kind of embedded toggle \
// button. The user can toggle the item accordingly.
$rect <519,90,719,130>
$output false
class ToggleItem : Templates::ToggleItem
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,220,40>;

  $rect <940,190,1140,230>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       minimum width for the item.

    */

    // We assume: the item requires space for the caption and 25 pixel margin on
    // the left and on the right of the caption plus the space needed for the item's
    // toggle area. Important: perform the calculation without the caption text being
    // evtl. truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 25 + KnobBorder.Bounds.w, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    // isChecked  --> the item is in its 'ON' state.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;
    var bool isChecked  = Active;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      
      CaptionText.Color = #888888FF;
    }

    else if ( isPressed )
    {
     
      CaptionText.Color = #000000FF;
    }

    else if ( isSelected )
    {
     
      CaptionText.Color = #000000FF;
    }

    // Enabled but not pressed nor selected.
    else
    {

      CaptionText.Color = #000000FF;
    }

    // Then arrange the knob at the position corresponding to the item's current
    // state.
    if      ( isPressed ) Knob.Bounds.origin.x = KnobBorder.Bounds.center.x - ( Knob.Bounds.w / 2 );
    else if ( isChecked ) Knob.Bounds.origin.x = KnobBorder.Bounds.x2 - Knob.Bounds.w - 4;
    else                  Knob.Bounds.origin.x = KnobBorder.Bounds.x1 + 4;

    // Finally set the color of the knob depending on the item's state.
    if      ( isPressed )               Knob.Color = #888888FF;
    else if ( isEnabled &&  isChecked ) Knob.Color = #00CC00FF;
    else if ( isEnabled && !isChecked ) Knob.Color = #FF0000FF;
    else if ( isChecked )               Knob.Color = #44FF44FF;
    else                                Knob.Color = #FF4444FF;

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
    checked  = isChecked;
  }

  // Controller events
  note group Note7
  {
    attr Bounds = <240,290,460,380>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,150,1150,240>;
  }

  // To do:
  // 
  // - Adjust the visible size of your item (the thick blue border). This will be \
  // the item's default size.
  // - Resize the member 'TouchHandler' so it still fills the items's toggle new \
  // area.
  // - Remove the 'Background' and 'Border' members if you want other decoration \
  // views to be shown instead these in your item.
  // - Remove the 'Knob' and 'KnobBorder' members if you want other views to show \
  // the toggle state instead these in your item.
  // - If you don't want the caption text to be shown, remove also the members 'CaptionText' \
  // and the property 'Caption' together with its 'OnSetCaption' method.
  // - According to your desired item design add and configure new views (e.g. an \
  // image view to show an icon in the item, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the item's current state.
  // - You can also add and configure animation effects to your item. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your item.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the item itself is resized.
  // - Adapt the method GetMinimalSize(). The method should calculate the minimum \
  // width the item will occupy within the menu.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // item to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your item. One property \
  // for every item specific setting (e.g. 'Icon', 'Color', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your item where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,410,990,820>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,350,910,390>
  var bool checked;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the item will update itself.
  $rect <250,330,450,370>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the toggle item.
    if ( Outlet != null )
      Active = Outlet^;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    // Toggle the item's state and notify the owner of the item.
    Active = !Active;
    postsignal OnToggle;

    // If a property is associated to the item, update it accordingly and notify
    // other widgets also associated to this property.
    if ( Outlet != null )
    {
      Outlet^ = Active;
      notifyobservers Outlet; 
    }
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      FlashTimer.Enabled = false;

      // Toggle the item's state and notify the owner of the item.
      Active = !Active;
      postsignal OnToggle;

      // If a property is associated to the item, update it accordingly and notify
      // other widgets also associated to this property.
      if ( Outlet != null )
      {
        Outlet^ = Active;
        notifyobservers Outlet; 
      }
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item's toggle area. This only updates the item to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the toggle area or drags the finger inside/outside
    // the area, request the item updates its appearance. The update will occur in the
    // UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's toggle area. This toggles the item.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the toggle area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
    {
      // Toggle the item's state and notify the owner of the item.
      Active = !Active;
      postsignal OnToggle;

      // If a property is associated to the item, update it accordingly and notify
      // other widgets also associated to this property.
      if ( Outlet != null )
      {
        Outlet^ = Active;
        notifyobservers Outlet; 
      }
    }

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the items's toggle \
  // area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // Clicking on a menu item focuses (selects) the item. If you don't want it,
    // remove the following code line.
    Owner.Focus = this;

    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      FlashTimer.Enabled = false;

      // Toggle the item's state and notify the owner of the item.
      Active = !Active;
      postsignal OnToggle;

      // If a property is associated to the item, update it accordingly and notify
      // other widgets also associated to this property.
      if ( Outlet != null )
      {
        Outlet^ = Active;
        notifyobservers Outlet; 
      }
    }
  }

  $rect <650,50,850,90>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <450,50,650,90>
  onset Active
  {
    // Check if the given value differs from the current value
    if ( pure Active == value )
      return;

    // Store the new state ...
    pure Active = value;

    // ... and finally, request an update
    InvalidateViewState();
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <10,0,169,40>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Border KnobBorder
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Bounds = <174,6,214,34>;
    preset Color = #808080FF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop];
    preset Point4 = <174,33>;
    preset Point3 = <213,33>;
    preset Point2 = <213,6>;
    preset Point1 = <174,6>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Knob
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <170,10,190,30>;
    preset Color = #FF0000FF;
  }

  // The property 'OnToggle' can refer to a slot method, which will receive a signal \
  // as soon as the user has toggled the item. Thereupon the method's logic will \
  // be executed. In the associated slot method you can evaluate the current value \
  // of the property @Active.
  $rect <850,10,1050,50>
  property slot OnToggle = null;

  // The property 'Outlet' can refer to any other 'bool' property the item should \
  // remain synchronized with. When the user toggles the item, the affected property \
  // is automatically updated to reflect the item's current state. On the other hand, \
  // when the referred property is modified by another one, the toggle item is automatically \
  // notified to remain in sync with the property.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the toggle item represents the 'View' and 'Controller' and the property \
  // referred via 'Outlet' can be seen as a part of the 'Model'.
  $rect <650,10,850,50>
  property ^bool Outlet = null;

  // The property 'Active' stores the current state of the toggle item. As long as \
  // the property is 'false', the widget should appear in switched-off state. As \
  // long as the property is 'true', the widget should appear in switched-on state.
  $rect <450,10,650,50>
  property bool Active = false;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";
}

// This component implements a menu item separator.
$rect <519,130,719,170>
$output false
class TemperatureDisplay : Templates::MenuSeparatorItem
{
  $rect <10,80,200,120>
  inherited property Bounds = <0,0,220,64>;

  // This example demonstrates how to implement a menu system using Embedded Wizard \
  // Studio.
  // 
  // This concrete GUI component implements the 'Menu Separator Item' component.
  // 
  // To create such menu item we used the 'Menu Separator Item' template found in \
  // the Gallery folder 'Component Templates'.
  // 
  // After adding the template, we adapted it so it has the particular look&feel \
  // of this example.
  // 
  // Similarly, you use the Gallery 'Menu Separator Item' template to add your own \
  // menu item components to your project. Then you can modify the appearance and \
  // the behaviour of the menu item according to your individual design expectations.
  note legend Note
  {
    attr Bounds = <10,150,990,340>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <-29,2,171,63>;
    preset Outlet = ^FishTank::Device.Temperature;
    preset Unit = "C";
    preset Precision = 1;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }
}

$rect <1280,370,1480,410>
$output false
resource Resources::Bitmap RedColor
{
  attr bitmapfile FileName = .\Resources\RedColor.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1280,410,1480,450>
$output false
resource Resources::Bitmap BlueColor
{
  attr bitmapfile FileName = .\Resources\BlueColor.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1280,450,1480,490>
$output false
resource Resources::Bitmap WhireColor
{
  attr bitmapfile FileName = .\Resources\WhiteColor.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1070,150,1270,190>
$output false
resource Resources::Bitmap Rectangle
{
  attr bitmapfile FileName = .\Resources\Rectangle.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This component implements a simple menu item containing a kind of embedded radio \
// button. The user can select the item within a group of items existing in the same \
// menu.
$rect <720,370,920,410>
$output false
class RadioItem1 : Templates::RadioItem
{
  $rect <480,360,680,400>
  inherited property Bounds = <0,0,286,53>;

  $rect <940,240,1140,280>
  inherited method GetMinimalSize()
  {
    /*
       Calculate the minimum size of the item so the complete caption is visible.

       TO DO:

       If you have modified the appearance of the menu item, added some views or
       changed the layout of the item - adapt the following code and calculate the
       miniumum width for the item.

    */

    // We assume: the item requires space for the caption, 60 pixel margin on
    // its left side and some space for the check image on the right.
    // Important: perform the calculation without the caption text being evtl.
    // truncated and replaced by an ellipsis sign.
    var bool  ellipsis   = CaptionText.Ellipsis;
    CaptionText.Ellipsis = false;
    var point size       = point( CaptionText.GetContentArea().w + 60 + CheckImage.Bounds.w, 0 );
    CaptionText.Ellipsis = ellipsis;

    return size;
  }

  $rect <710,240,910,280>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the item.
    //
    // isEnabled  --> the item can react to user inputs.
    // isSelected --> the item can receive keyboard events.
    // isPressed  --> the item should appear pressed.
    // isChecked  --> the item is in its 'ON' state.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;
    var bool isChecked  = Selected;

    /*

      TO DO:

      Depending on your item design, you have surely added some new views
      to your item. In the below code you should update the properties of
      these views. For example, when your item has two images to appear
      exclusively for released and pressed item state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
     Border.Color=#ffffffff;

    }

    else if ( isPressed )
    {
           Border.Color=#ffffffff;
    }

    else if ( isSelected )
    {
               Border.Color=#ffffffff;
    }

    // Enabled but not pressed nor selected.
    else
    {
                    Border.Color=#00000000;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
    checked  = isChecked;
  }

  // Controller events
  note group Note8
  {
    attr Bounds = <240,340,460,430>;
  }

  // Layout management
  note group Note6
  {
    attr Bounds = <930,200,1150,290>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,200,920,450>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,200,690,330>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,200,460,330>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,200,230,370>;
  }

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,400,910,440>
  var bool checked;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,360,910,400>
  var bool pressed;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,320,910,360>
  var bool selected;

  // This variable stores the current state of the item. Please see the comments \
  // inside UpdateViewState().
  $rect <710,280,910,320>
  var bool enabled;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,240,680,280>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,240,450,280>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <250,380,450,420>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the radio item.
    if ( Outlet != null )
      Selected = Outlet^ == OutletSelector;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,280,680,320>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    // Select the item and notify the owner of the item.
    if ( !Selected )
    {
      Selected = true;
      postsignal OnSelect;

      // If a property is associated to the item, update it accordingly and notify
      // other widgets also associated to this property.
      if ( Outlet != null )
      {
        Outlet^ = OutletSelector;
        notifyobservers Outlet; 
      }
    }

  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,280,450,320>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The item is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the item or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      // Select the item and notify the owner of the item.
      if ( !Selected )
      {
        Selected = true;
        postsignal OnSelect;

        // If a property is associated to the item, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,320,220,360>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,280,220,320>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the item's area? In such case
    // the item is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The touch interaction has been passed over to another touch handler.
    // The item is not activated in such case.
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
    {
      // Select the item and notify the owner of the item.
      if ( !Selected )
      {
        Selected = true;
        postsignal OnSelect;

        // If a property is associated to the item, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the item's area.
  $rect <20,240,220,280>
  slot onPressTouch
  {
    // The item is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the item in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new item interaction.
    if ( FlashTimer.Enabled )
    {
      // Select the item and notify the owner of the item.
      if ( !Selected )
      {
        Selected = true;
        postsignal OnSelect;

        // If a property is associated to the item, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
      FlashTimer.Enabled = false;
    }
  }

  $rect <650,140,850,180>
  onset OutletSelector
  {
    // Check if the given value differs from the current value
    if ( pure OutletSelector == value )
      return;

    pure OutletSelector = value;

    // Update the current state of the widget
    if ( Outlet != null )
      Selected = ( Outlet^ == OutletSelector );
  }

  $rect <450,140,650,180>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <250,140,450,180>
  onset Selected
  {
    // Check if the given value differs from the current value
    if ( pure Selected == value )
      return;

    // Store the new state ...
    pure Selected = value;

    // ... and finally, request an update
    InvalidateViewState();
  }

  $rect <450,50,650,90>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the icon in the menu
    Image.Bitmap = value;
  }

  $rect <250,50,450,90>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  // This is a generic touch handler.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <115,44>;
    preset Point3 = <231,44>;
    preset Point2 = <231,5>;
    preset Point1 = <115,5>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToTop, ResizeVert];
    preset Bounds = <124,4,164,44>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // as soon as the user has selected the radio item. Thereupon the method's logic \
  // will be executed.
  $rect <850,100,1050,140>
  property slot OnSelect = null;

  // The property 'OutletSelector' contains a value identifying the radio item within \
  // a group of radio items. At the runtime, the item compares this value with the \
  // value of the property referred by @Outlet and if both are equal, the radio item \
  // assumes the 'selected' state (its property @Selected is 'true'). If the values \
  // are different, the radio item appears not selected. This selector is useful \
  // to build a group of radio item that refers to the same outlet. Different selectors \
  // for each radio item manages automatically the group of radio items.
  $rect <650,100,850,140>
  property int32 OutletSelector = 0;

  // The property 'Outlet' can refer to any other 'int32' property the item should \
  // remain synchronized with. When the user selects the radio item, the affected \
  // property is automatically updated to the value found in the property @OutletSelector. \
  // On the other hand, when the referred property is modified by another one, the \
  // radio item is automatically notified to remain in sync with the property. The \
  // item appears selected, when the referred property has the value equal to @OutletSelector.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the radio item represents the 'View' and the property referred via 'Outlet' \
  // can be seen as a part of the 'Model'.
  $rect <450,100,650,140>
  property ^int32 Outlet = null;

  // The property 'Selected' stores the current state of the radio item. As long \
  // as the property is 'false', the item should appear in the not-selected state. \
  // As long as the property is 'true', the item should appear in selected state.
  $rect <250,100,450,140>
  property bool Selected = false;

  // The property 'Icon' can refer to a bitmap to show in the menu's caption area.
  $rect <450,10,650,50>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;

  // The property 'Caption' stores the text to display within the item. 
  $rect <250,10,450,50>
  property string Caption = "Caption";

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <124,4,164,32>;
    preset Color = #22BBFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <4,6,179,46>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Caption";
    preset Font = Resources::FontMedium;
    preset Color = #FFFFFFFF;
  }
}

// This component implements a menu item separator.
$rect <519,170,719,210>
$output false
class TemperatureNote : Templates::MenuSeparatorItem
{
  $rect <280,40,470,80>
  inherited property Bounds = <0,0,267,94>;

  // This example demonstrates how to implement a menu system using Embedded Wizard \
  // Studio.
  // 
  // This concrete GUI component implements the 'Menu Separator Item' component.
  // 
  // To create such menu item we used the 'Menu Separator Item' template found in \
  // the Gallery folder 'Component Templates'.
  // 
  // After adding the template, we adapted it so it has the particular look&feel \
  // of this example.
  // 
  // Similarly, you use the Gallery 'Menu Separator Item' template to add your own \
  // menu item components to your project. Then you can modify the appearance and \
  // the behaviour of the menu item according to your individual design expectations.
  note legend Note
  {
    attr Bounds = <10,150,990,340>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <2,2,266,93>;
    preset String = "Ideal Temperature Range:\n Most tropical freshwater fish\n thrive in temperatures\n ranging from \n75°F to 82°F (24°C to 28°C). ";
    preset Font = Resources::FontSmall;
  }
}
